import ¬´TT-model¬ª.syntactics
import ¬´TT-model¬ª.reduction
import ¬´TT-model¬ª.typing

open Nat
open Term

set_option autoImplicit false
set_option pp.fieldNotation false

variable [LevelClass]

/-*----------------------
  Well-scoped renamings
----------------------*-/

def wRename Œæ Œì Œî := ‚àÄ x A, Œì ‚àã x ‚à∂ A ‚Üí Œî ‚àã Œæ x ‚à∂ rename Œæ A
notation:40 Œî:41 "‚ä¢" Œæ:41 "‚à∂" Œì:41 => wRename Œæ Œì Œî

theorem wRenameLift {Œæ : ‚Ñï ‚Üí ‚Ñï} {Œì Œî A}
  (h : Œî ‚ä¢ Œæ ‚à∂ Œì) :
  Œî ‚à∑ (rename Œæ A) ‚ä¢ lift Œæ ‚à∂ Œì ‚à∑ A := by
  intro x B mem
  cases mem with
  | here => apply inHere; simp [renameComp]; rfl
  | there => apply inThere; apply_rules [h]; simp [h, renameComp]; rfl

theorem wRenameSucc {Œì A} : Œì ‚à∑ A ‚ä¢ succ ‚à∂ Œì := by
  intro x B mem; constructor; assumption

/-*------------------------------
  Renaming and weakening lemmas
------------------------------*-/

theorem wtRename {Œæ : ‚Ñï ‚Üí ‚Ñï} {Œì Œî} {a A : Term}
  (hŒæ : Œî ‚ä¢ Œæ ‚à∂ Œì) (hŒî : ‚ä¢ Œî) (h : Œì ‚ä¢ a ‚à∂ A) :
  Œî ‚ä¢ rename Œæ a ‚à∂ rename Œæ A := by
  generalize e : @Sigma.mk I idx I.wt ‚ü®Œì, a, A‚ü© = t at h
  induction h generalizing Œæ Œì Œî a A
  all_goals injection e with eI e; injection eI
  all_goals injection e with eCtxt eTerm eType;
            subst eCtxt; subst eTerm; subst eType
  case var => constructor; assumption; apply_rules [hŒæ]
  case ùí∞ ih => exact Wtf.ùí∞ (ih hŒæ hŒî rfl)
  case pi ihA ihB =>
    let ihA' := ihA hŒæ hŒî rfl
    refine Wtf.pi ihA' ?_
    rw [renameLiftRename]
    exact ihB (wRenameLift hŒæ) (Wtf.cons hŒî ihA') rfl
  case abs ihPi ihb =>
    let ihPi' := ihPi hŒæ hŒî rfl
    refine Wtf.abs ihPi' ?_
    let ‚ü®k, hA‚ü© := wtfPiInvA ihPi'
    exact ihb (wRenameLift hŒæ) (Wtf.cons hŒî hA) rfl
  case app ihb iha => rw [‚Üê renameDist]; exact Wtf.app (ihb hŒæ hŒî rfl) (iha hŒæ hŒî rfl)
  case mty ih => exact Wtf.mty (ih hŒæ hŒî rfl)
  case exf ihA _ ihb => exact Wtf.exf (ihb hŒæ hŒî rfl) (ihA hŒæ hŒî rfl)
  case lvl ih => exact Wtf.lvl (ih hŒæ hŒî rfl)
  case lof => constructor <;> assumption
  case trans ihi _ ihj => exact Wtf.trans (ihj hŒæ hŒî rfl) (ihi hŒæ hŒî rfl)
  case conv B _ _ iha h _ ihA =>
    exact Wtf.conv (convEqv (convRename Œæ (eqvConv h))) (iha hŒæ hŒî rfl) (ihA hŒæ hŒî rfl)
  case sub ihj _ ihA => exact Wtf.sub (ihj hŒæ hŒî rfl) (ihA hŒæ hŒî rfl)

theorem wtWeaken {Œì k} {a A B : Term}
  (hŒì : ‚ä¢ Œì) (hB : Œì ‚ä¢ B ‚à∂ ùí∞ k) (h : Œì ‚ä¢ a ‚à∂ A) :
  Œì ‚à∑ B ‚ä¢ rename succ a ‚à∂ rename succ A := by
  apply wtRename wRenameSucc (Wtf.cons hŒì hB) h

/-*-------------------------
  Well-typed substitutions
-------------------------*-/

def wSubst œÉ Œì Œî := ‚àÄ x A, Œì ‚àã x ‚à∂ A ‚Üí Œî ‚ä¢ œÉ x ‚à∂ subst œÉ A
notation:40 Œî:41 "‚ä¢" œÉ:41 "‚à∂" Œì:41 => wSubst œÉ Œì Œî

theorem wSubstUp {œÉ Œî Œì k A}
  (hA : Œî ‚ä¢ subst œÉ A ‚à∂ ùí∞ k)
  (h : Œî ‚ä¢ œÉ ‚à∂ Œì) :
  Œî ‚à∑ subst œÉ A ‚ä¢ ‚áë œÉ ‚à∂ Œì ‚à∑ A := by
  intro x B mem; cases mem
  all_goals rw [‚Üê renameUpSubst]
  . exact Wtf.var (Wtf.cons (wtWf hA) hA) In.here
  . refine wtWeaken (wtWf hA) hA (h _ _ ?_); assumption

theorem wSubstCons {Œì} {a A : Term}
  (h : Œì ‚ä¢ a ‚à∂ A) :
  Œì ‚ä¢ a +: var ‚à∂ Œì ‚à∑ A := by
  intro x B mem; cases mem
  all_goals rw [‚Üê substDrop]
  . exact h
  . refine Wtf.var (wtWf h) ?_; assumption

/-*---------------------------------
  Morphing and substitution lemmas
  (corollary: replacement)
---------------------------------*-/

theorem wtMorph {œÉ : ‚Ñï ‚Üí Term} {Œì Œî} {a A : Term}
  (hœÉ : Œî ‚ä¢ œÉ ‚à∂ Œì) (hŒî : ‚ä¢ Œî) (h : Œì ‚ä¢ a ‚à∂ A) :
  Œî ‚ä¢ subst œÉ a ‚à∂ subst œÉ A := by
  generalize e : @Sigma.mk I idx I.wt ‚ü®Œì, a, A‚ü© = t at h
  induction h generalizing œÉ Œì Œî a A
  all_goals injection e with eI e; injection eI
  all_goals injection e with eCtxt eTerm eType;
            subst eCtxt; subst eTerm; subst eType
  case var mem => exact hœÉ _ _ mem
  case ùí∞ ih => exact Wtf.ùí∞ (ih hœÉ hŒî rfl)
  case pi ihA ihB =>
    let ihA' := ihA hœÉ hŒî rfl
    refine Wtf.pi ihA' ?_
    rw [renameUpSubst]
    exact ihB (wSubstUp ihA' hœÉ) (Wtf.cons hŒî ihA') rfl
  case abs ihPi ihb =>
    let ihPi' := ihPi hœÉ hŒî rfl
    refine Wtf.abs ihPi' ?_
    let ‚ü®k, hA‚ü© := wtfPiInvA ihPi'
    exact ihb (wSubstUp hA hœÉ) (Wtf.cons hŒî hA) rfl
  case app ihb iha => rw [‚Üê substDist]; exact Wtf.app (ihb hœÉ hŒî rfl) (iha hœÉ hŒî rfl)
  case mty ih => exact Wtf.mty (ih hœÉ hŒî rfl)
  case exf ihA _ ihb => exact Wtf.exf (ihb hœÉ hŒî rfl) (ihA hœÉ hŒî rfl)
  case lvl ih => exact Wtf.lvl (ih hœÉ hŒî rfl)
  case lof => constructor <;> assumption
  case trans ihi _ ihj => exact Wtf.trans (ihj hœÉ hŒî rfl) (ihi hœÉ hŒî rfl)
  case conv B _ _ iha h _ ihA =>
    refine Wtf.conv (convEqv (convSubst œÉ (eqvConv h))) (iha hœÉ hŒî rfl) (ihA hœÉ hŒî rfl)
  case sub ihj _ ihA => exact Wtf.sub (ihj hœÉ hŒî rfl) (ihA hœÉ hŒî rfl)

theorem wtSubst {Œì} {a A b B : Term}
  (hb : Œì ‚ä¢ b ‚à∂ B) (h : Œì ‚à∑ B ‚ä¢ a ‚à∂ A) :
  Œì ‚ä¢ subst (b +: var) a ‚à∂ subst (b +: var) A := by
  apply wtMorph (wSubstCons hb) (wtWf hb) h

theorem wtReplace {Œì} {A B c C k : Term}
  (e : A ‚âà B)
  (hB : Œì ‚ä¢ B ‚à∂ ùí∞ k)
  (h : Œì ‚à∑ A ‚ä¢ c ‚à∂ C) :
  Œì ‚à∑ B ‚ä¢ c ‚à∂ C := by
  cases wtWf h with | cons wfŒì hA =>
  let wfŒìB := Wtf.cons wfŒì hB
  rw [‚Üê substId c, ‚Üê substId C]
  refine wtMorph ?_ wfŒìB h
  intro x A mem; rw [substId]; cases mem
  case here =>
    exact Wtf.conv
      (convEqv (convRename succ (convSym (eqvConv e))))
      (Wtf.var wfŒìB In.here)
      (wtWeaken wfŒì hB hA)
  case there mem => exact Wtf.var wfŒìB (In.there mem)

/-*-----------
  Regularity
-----------*-/

theorem wtMem {Œì x A} (mem : Œì ‚àã x ‚à∂ A) (h : ‚ä¢ Œì) : ‚àÉ k, Œì ‚ä¢ A ‚à∂ ùí∞ k := by
  induction mem
  case here =>
    cases h with
    | cons hŒì hB =>
      exact ‚ü®rename succ _, wtWeaken hŒì hB hB‚ü©
  case there ih =>
    cases h with
    | cons hŒì hB =>
      let ‚ü®k, hA‚ü© := ih hŒì
      exact ‚ü®rename succ k, wtWeaken hŒì hB hA‚ü©

theorem wtRegularity {Œì} {a A : Term} (h : Œì ‚ä¢ a ‚à∂ A) : ‚àÉ k, Œì ‚ä¢ A ‚à∂ ùí∞ k := by
  generalize e : @Sigma.mk I idx I.wt ‚ü®Œì, a, A‚ü© = t at h
  induction h generalizing Œì a A
  all_goals injection e with eI e; injection eI
  all_goals injection e with eCtxt eTerm eType;
            subst eCtxt; subst eTerm; subst eType
  case var wf _ mem => exact wtMem mem wf
  case ùí∞ j k _ ih =>
    let ‚ü®_, ihk‚ü© := ih rfl
    let ‚ü®l, _, hk, _‚ü© := wtfLvlInv ihk
    exact ‚ü®l, Wtf.ùí∞ hk‚ü©
  case pi ihA _ => exact ihA rfl
  case abs hPi _ _ _ => exact ‚ü®_, hPi‚ü©
  case app ha ihb _ =>
    let ‚ü®_, hPi‚ü© := ihb rfl
    let ‚ü®k, hB‚ü© := wtfPiInvB hPi
    exact ‚ü®subst _ k, wtSubst ha hB‚ü©
  case mty hj _ => exact ‚ü®_, Wtf.ùí∞ hj‚ü©
  case exf hA _ => exact ‚ü®_, hA‚ü©
  case lvl k ha _ =>
    let ‚ü®l, klgt‚ü© := exists_gt k
    exact ‚ü®lof l, Wtf.ùí∞ (Wtf.lof (wtWf ha) klgt)‚ü©
  case lof k _ wf _ =>
    let ‚ü®l, klgt‚ü© := exists_gt k
    exact ‚ü®lof l, Wtf.lvl (Wtf.lof wf klgt)‚ü©
  case trans ih _ _ => exact ih rfl
  case conv hA _ => exact ‚ü®_, hA‚ü©
  case sub ih _ _ =>
    let ‚ü®_, ihk‚ü© := ih rfl
    let ‚ü®l, _, hk, _‚ü© := wtfLvlInv ihk
    exact ‚ü®l, Wtf.ùí∞ hk‚ü©

/-*-------------
  Preservation
-------------*-/

theorem wtPar {Œì} {a b A : Term} (r : a ‚áí b) (h : Œì ‚ä¢ a ‚à∂ A) : Œì ‚ä¢ b ‚à∂ A := by
  generalize e : @Sigma.mk I idx I.wt ‚ü®Œì, a, A‚ü© = t at h
  induction h generalizing Œì a b A
  all_goals injection e with eI e; injection eI
  all_goals injection e with eCtxt eTerm eType;
            subst eCtxt; subst eTerm; subst eType
  case var => cases r; constructor <;> assumption
  case ùí∞ ih => cases r with | ùí∞ r' => exact Wtf.ùí∞ (ih r' rfl)
  case pi ihA ihB =>
    cases r with | pi ra rb =>
    let ihA' := ihA ra rfl
    exact Wtf.pi ihA' (wtReplace (parEqv ra) ihA' (ihB rb rfl))
  case abs hPi _ _ ihb => cases r with | abs r' => exact Wtf.abs hPi (ihb r' rfl)
  case app hb ha ihb iha =>
    cases r
    case Œ≤ rb ra =>
      let ‚ü®_, hA‚ü© := wtRegularity ha
      let ‚ü®_, hPi‚ü© := wtRegularity hb
      let ‚ü®_, hB‚ü© := wtfPiInvB hPi
      let ‚ü®A', B', hb', e‚ü© := wtfAbsInv (ihb (Par.abs rb) rfl)
      let ‚ü®eA, eB‚ü© := convPiInv (eqvConv e)
      exact Wtf.conv
        (convEqv (convCong (convSym (parConv ra)) eB))
        (wtSubst (iha ra rfl) (wtReplace (convEqv eA) hA hb'))
        (wtSubst ha hB)
    case app rb ra =>
      let ‚ü®k, hBa‚ü© := wtRegularity (Wtf.app hb ha)
      exact Wtf.conv
        (convEqv (convSym (parConv (parCong ra (parRefl _)))))
        (Wtf.app (ihb rb rfl) (iha ra rfl)) hBa
  case mty ih => cases r; exact Wtf.mty (ih (parRefl _) rfl)
  case exf ihb hA _ => cases r with | exf r' => exact Wtf.exf hA (ihb r' rfl)
  case lvl ih => cases r with | lvl r' => exact Wtf.lvl (ih r' rfl)
  case lof => cases r; constructor <;> assumption
  case trans hj _ _ ihi => exact Wtf.trans (ihi r rfl) hj
  case conv iha eqv hB _ => exact Wtf.conv eqv (iha r rfl) hB
  case sub hj _ _ ihA => exact Wtf.sub hj (ihA r rfl)

theorem wtPars {Œì} {a b A : Term} (r : a ‚áí‚ãÜ b) (h : Œì ‚ä¢ a ‚à∂ A) : Œì ‚ä¢ b ‚à∂ A := by
  induction r <;> apply_rules [wtPar]

/-*---------
  Progress
---------*-/

inductive Value : Term ‚Üí Prop where
  | ùí∞ {k} : Value (ùí∞ k)
  | pi {a b} : Value (pi a b)
  | abs {b} : Value (abs b)
  | mty : Value mty
  | lvl {k} : Value (lvl k)
  | lof {k} : Value (lof k)

inductive CBN : Term ‚Üí Term ‚Üí Prop where
  | Œ≤ {b a} : CBN (app (abs b) a) (subst (a +: var) b)
  | app {b b' a} : CBN b b' ‚Üí CBN (app b a) (app b' a)
  | exf {b b'} : CBN b b' ‚Üí CBN (exf b) (exf b')

infix:40 "‚áíŒ≤" => CBN

theorem CBNpar {a b} : a ‚áíŒ≤ b ‚Üí a ‚áí b
  | CBN.Œ≤ => Par.Œ≤ (parRefl _) (parRefl _)
  | CBN.app rb => Par.app (CBNpar rb) (parRefl _)
  | CBN.exf rb => Par.exf (CBNpar rb)

theorem wtMty {b : Term} (v : Value b) (h : ‚¨ù ‚ä¢ b ‚à∂ mty) : False := by
  generalize e : @Sigma.mk I idx I.wt ‚ü®‚¨ù, b, mty‚ü© = t at h
  induction h generalizing b
  all_goals injection e with eI e; injection eI
  all_goals injection e with eCtxt eTerm eType;
            subst eCtxt; subst eTerm
  all_goals try first | contradiction | subst eType
  case conv ih emty _ _ =>
  cases v
  case ùí∞ h =>
    let ‚ü®_, eùí∞‚ü© := wtfùí∞Inv h
    cases convùí∞Mty (eqvConv (Eqv.trans eùí∞ emty))
  case pi h =>
    let ‚ü®_, eùí∞‚ü© := wtfPiInvùí∞ h
    cases convùí∞Mty (eqvConv (Eqv.trans eùí∞ emty))
  case abs hb =>
    let ‚ü®_, _, _, epi‚ü© := wtfAbsInv hb
    cases convMtyPi (eqvConv (Eqv.sym (Eqv.trans epi emty)))
  case mty h =>
    let ‚ü®_, eùí∞‚ü© := wtfMtyInv h
    cases convùí∞Mty (eqvConv (Eqv.trans eùí∞ emty))
  case lvl h =>
    let ‚ü®_, _, _, eùí∞‚ü© := wtfLvlInv h
    cases convùí∞Mty (eqvConv (Eqv.trans eùí∞ emty))
  case lof h =>
    let ‚ü®_, elvl‚ü© := wtfLofInv h
    cases convLvlMty (eqvConv (Eqv.trans elvl emty))

theorem wtProgress {a A : Term} (h : ‚¨ù ‚ä¢ a ‚à∂ A) : Value a ‚à® ‚àÉ b, a ‚áíŒ≤ b := by
  generalize e : @Sigma.mk I idx I.wt ‚ü®‚¨ù, a, A‚ü© = t at h
  induction h generalizing a A
  all_goals injection e with eI e; injection eI
  all_goals injection e with eCtxt eTerm eType;
            subst eCtxt; subst eTerm; subst eType
  case var mem => cases mem
  case ùí∞ | pi | abs | mty | lvl | lof => repeat constructor
  case trans ih | conv ih _ _ _ | sub ih => exact ih rfl
  case app ihb _ =>
    cases ihb rfl
    case inl v => sorry
    case inr r => let ‚ü®_, r‚ü© := r; exact Or.inr ‚ü®_, CBN.app r‚ü©
  case exf hb ihb _ _ =>
    cases ihb rfl
    case inl v => cases wtMty v hb
    case inr r => let ‚ü®_, r‚ü© := r; exact Or.inr ‚ü®_, CBN.exf r‚ü©

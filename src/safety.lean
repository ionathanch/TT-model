import ¬´src¬ª.typing

open Nat
open Term

set_option autoImplicit false
set_option pp.fieldNotation false

variable [LevelClass]

/-*------------------------------
  Renaming and weakening lemmas
------------------------------*-/

theorem wtRename {Œæ : ‚Ñï ‚Üí ‚Ñï} {Œì Œî} {a A : Term}
  (hŒæ : Œî ‚ä¢ Œæ ‚à∂ Œì) (hŒî : ‚ä¢ Œî) (h : Œì ‚ä¢ a ‚à∂ A) :
  Œî ‚ä¢ rename Œæ a ‚à∂ rename Œæ A := by
  induction h using wtInd generalizing Œæ Œî
  case var => constructor; assumption; apply_rules [hŒæ]
  case ùí∞ ih => exact Wt.ùí∞ (ih hŒæ hŒî)
  case pi ihA ihB =>
    let ihA' := ihA hŒæ hŒî
    refine Wt.pi ihA' ?_
    rw [renameLiftRename]
    exact ihB (wRenameLift hŒæ) (Wf.cons hŒî ihA')
  case abs ihPi ihA ihb =>
    let ihPi' := ihPi hŒæ hŒî
    refine Wt.abs ihPi' (ihA hŒæ hŒî) ?_
    let ‚ü®k, hA‚ü© := wtfPiInvA ihPi'
    exact ihb (wRenameLift hŒæ) (Wf.cons hŒî hA)
  case app ihb iha => rw [‚Üê renameDist]; exact Wt.app (ihb hŒæ hŒî) (iha hŒæ hŒî)
  case mty ih => exact Wt.mty (ih hŒæ hŒî)
  case exf ihb ihA => exact Wt.exf (ihb hŒæ hŒî) (ihA hŒæ hŒî)
  case lvl iha ihj => exact Wt.lvl (iha hŒæ hŒî) (ihj hŒæ hŒî)
  case lof => constructor <;> assumption
  case trans ihi ihj => exact Wt.trans (ihi hŒæ hŒî) (ihj hŒæ hŒî)
  case conv e _ _ iha ihA =>
    exact Wt.conv (convEqv (convRename Œæ (eqvConv e))) (iha hŒæ hŒî) (ihA hŒæ hŒî)
  case sub ihj ihA => exact Wt.sub (ihj hŒæ hŒî) (ihA hŒæ hŒî)

theorem wtWeaken {Œì k} {a A B : Term}
  (hŒì : ‚ä¢ Œì) (hB : Œì ‚ä¢ B ‚à∂ ùí∞ k) (h : Œì ‚ä¢ a ‚à∂ A) :
  Œì ‚à∑ B ‚ä¢ rename succ a ‚à∂ rename succ A := by
  apply wtRename wRenameSucc (Wf.cons hŒì hB) h

/-*-------------------------
  Well-typed substitutions
-------------------------*-/

def wSubst œÉ Œì Œî := ‚àÄ x A, Œì ‚àã x ‚à∂ A ‚Üí Œî ‚ä¢ œÉ x ‚à∂ subst œÉ A
notation:40 Œî:41 "‚ä¢" œÉ:41 "‚à∂" Œì:41 => wSubst œÉ Œì Œî

theorem wSubstUp {œÉ Œî Œì k A}
  (hA : Œî ‚ä¢ subst œÉ A ‚à∂ ùí∞ k)
  (h : Œî ‚ä¢ œÉ ‚à∂ Œì) :
  Œî ‚à∑ subst œÉ A ‚ä¢ ‚áë œÉ ‚à∂ Œì ‚à∑ A := by
  intro x B mem; cases mem
  all_goals rw [‚Üê renameUpSubst]
  . exact Wt.var (Wf.cons (wtWf hA) hA) In.here
  . refine wtWeaken (wtWf hA) hA (h _ _ ?_); assumption

theorem wSubstCons {Œì} {a A : Term}
  (h : Œì ‚ä¢ a ‚à∂ A) :
  Œì ‚ä¢ a +: var ‚à∂ Œì ‚à∑ A := by
  intro x B mem; cases mem
  all_goals rw [‚Üê substDrop]
  . exact h
  . refine Wt.var (wtWf h) ?_; assumption

/-*---------------------------------
  Morphing and substitution lemmas
  (corollary: replacement)
---------------------------------*-/

theorem wtMorph {œÉ : ‚Ñï ‚Üí Term} {Œì Œî} {a A : Term}
  (hœÉ : Œî ‚ä¢ œÉ ‚à∂ Œì) (hŒî : ‚ä¢ Œî) (h : Œì ‚ä¢ a ‚à∂ A) :
  Œî ‚ä¢ subst œÉ a ‚à∂ subst œÉ A := by
  induction h using wtInd generalizing œÉ Œî
  case var mem _ => exact hœÉ _ _ mem
  case ùí∞ ih => exact Wt.ùí∞ (ih hœÉ hŒî)
  case pi ihA ihB =>
    let ihA' := ihA hœÉ hŒî
    refine Wt.pi ihA' ?_
    rw [renameUpSubst]
    exact ihB (wSubstUp ihA' hœÉ) (Wf.cons hŒî ihA')
  case abs ihPi ihA ihb =>
    let ihPi' := ihPi hœÉ hŒî
    let ‚ü®k, hA‚ü© := wtfPiInvA ihPi'
    exact Wt.abs ihPi' (ihA hœÉ hŒî) (ihb (wSubstUp hA hœÉ) (Wf.cons hŒî hA))
  case app ihb iha => rw [‚Üê substDist]; exact Wt.app (ihb hœÉ hŒî) (iha hœÉ hŒî)
  case mty ih => exact Wt.mty (ih hœÉ hŒî)
  case exf ihb ihA => exact Wt.exf (ihb hœÉ hŒî) (ihA hœÉ hŒî)
  case lvl iha ihj => exact Wt.lvl (iha hœÉ hŒî) (ihj hœÉ hŒî)
  case lof => constructor <;> assumption
  case trans ihi ihj => exact Wt.trans (ihi hœÉ hŒî) (ihj hœÉ hŒî)
  case conv e _ _ iha ihA =>
    refine Wt.conv (convEqv (convSubst œÉ (eqvConv e))) (iha hœÉ hŒî) (ihA hœÉ hŒî)
  case sub ihj ihA => exact Wt.sub (ihj hœÉ hŒî) (ihA hœÉ hŒî)

theorem wtSubst {Œì} {a A b B : Term}
  (hb : Œì ‚ä¢ b ‚à∂ B) (h : Œì ‚à∑ B ‚ä¢ a ‚à∂ A) :
  Œì ‚ä¢ subst (b +: var) a ‚à∂ subst (b +: var) A := by
  apply wtMorph (wSubstCons hb) (wtWf hb) h

theorem wtReplace {Œì} {A B c C k : Term}
  (e : A ‚âà B)
  (hB : Œì ‚ä¢ B ‚à∂ ùí∞ k)
  (h : Œì ‚à∑ A ‚ä¢ c ‚à∂ C) :
  Œì ‚à∑ B ‚ä¢ c ‚à∂ C := by
  cases wtWf h with | cons wfŒì hA =>
  let wfŒìB := Wf.cons wfŒì hB
  rw [‚Üê substId c, ‚Üê substId C]
  refine wtMorph ?_ wfŒìB h
  intro x A mem; rw [substId]; cases mem
  case here =>
    exact Wt.conv
      (convEqv (convRename succ (convSym (eqvConv e))))
      (Wt.var wfŒìB In.here)
      (wtWeaken wfŒì hB hA)
  case there mem => exact Wt.var wfŒìB (In.there mem)

/-*-----------
  Regularity
-----------*-/

theorem wtMem {Œì x A} (mem : Œì ‚àã x ‚à∂ A) (h : ‚ä¢ Œì) : ‚àÉ k, Œì ‚ä¢ A ‚à∂ ùí∞ k := by
  induction mem
  case here =>
    cases h with
    | cons hŒì hB =>
      exact ‚ü®rename succ _, wtWeaken hŒì hB hB‚ü©
  case there ih =>
    cases h with
    | cons hŒì hB =>
      let ‚ü®k, hA‚ü© := ih hŒì
      exact ‚ü®rename succ k, wtWeaken hŒì hB hA‚ü©

theorem wtRegularity {Œì} {a A : Term} (h : Œì ‚ä¢ a ‚à∂ A) : ‚àÉ k, Œì ‚ä¢ A ‚à∂ ùí∞ k := by
  induction h using wtInd
  case var wf mem _ => exact wtMem mem wf
  case pi ih _ | trans ih => exact ih
  case abs h _ _ _ _ _ | exf h _ _ _ | conv h _ _ => exact ‚ü®_, h‚ü©
  case ùí∞ ih =>
    let ‚ü®_, ihk‚ü© := ih
    let ‚ü®l, _, hk, _‚ü© := wtfLvlInv ihk
    exact ‚ü®l, Wt.ùí∞ hk‚ü©
  case app ha ihb _ =>
    let ‚ü®_, hPi‚ü© := ihb
    let ‚ü®k, hB‚ü© := wtfPiInvB hPi
    exact ‚ü®subst _ k, wtSubst ha hB‚ü©
  case mty hj _ => exact ‚ü®_, hj‚ü©
  case lvl hj _ _ => exact ‚ü®_, hj‚ü©
  case lof k wf _ _ =>
    let ‚ü®l, klgt‚ü© := exists_gt k
    let ‚ü®m, lmgt‚ü© := exists_gt l
    refine ‚ü®lof l, ?_‚ü©
    apply Wt.lvl (Wt.lof wf klgt)
    apply Wt.ùí∞ (Wt.lof wf lmgt)
  case sub ih _ =>
    let ‚ü®_, ihk‚ü© := ih
    let ‚ü®l, _, hk, _‚ü© := wtfLvlInv ihk
    exact ‚ü®l, Wt.ùí∞ hk‚ü©

theorem wtfAbs {Œì} {A B b k : Term}
  (hpi : Œì ‚ä¢ pi A B ‚à∂ ùí∞ k)
  (hb : Œì ‚à∑ A ‚ä¢ b ‚à∂ B) :
  Œì ‚ä¢ abs A b ‚à∂ pi A B := by
  let ‚ü®_, hA, e‚ü© := wtfPiInvAùí∞ hpi
  let ‚ü®_, hùí∞‚ü© := wtRegularity hpi
  refine Wt.abs hpi (Wt.conv e hA hùí∞) hb

/-*-------------
  Preservation
-------------*-/

theorem wtPar {Œì} {a b A : Term} (r : a ‚áí b) (h : Œì ‚ä¢ a ‚à∂ A) : Œì ‚ä¢ b ‚à∂ A := by
  induction h using wtInd generalizing b
  case var => cases r; constructor <;> assumption
  case ùí∞ ih => cases r with | ùí∞ r' => exact Wt.ùí∞ (ih r')
  case pi ihA ihB =>
    cases r with | pi ra rb =>
    let ihA' := ihA ra
    exact Wt.pi ihA' (wtReplace (parEqv ra) ihA' (ihB rb))
  case abs B _ _ hPi _ _ ihPi ihA ihb => cases r with | abs rA rb =>
    let rPi := Par.pi rA (parRefl B)
    let hb := wtReplace (convEqv (parConv rA)) (ihA rA) (ihb rb)
    exact Wt.conv
      (convEqv (convSym (parConv rPi)))
      (Wt.abs (ihPi rPi) (ihA rA) hb) hPi
  case app hb ha ihb iha =>
    cases r
    case Œ≤ rb ra =>
      let ‚ü®_, hA‚ü© := wtRegularity ha
      let ‚ü®_, hPi‚ü© := wtRegularity hb
      let ‚ü®_, hB‚ü© := wtfPiInvB hPi
      let ‚ü®A', B', hb', _, e‚ü© := wtfAbsInv (ihb (Par.abs (parRefl _) rb))
      let ‚ü®eA, eB‚ü© := convPiInv (eqvConv e)
      exact Wt.conv
        (convEqv (convCong (convSym (parConv ra)) eB))
        (wtSubst (iha ra) (wtReplace (convEqv eA) hA hb'))
        (wtSubst ha hB)
    case app rb ra =>
      let ‚ü®k, hBa‚ü© := wtRegularity (Wt.app hb ha)
      exact Wt.conv
        (convEqv (convSym (parConv (parCong ra (parRefl _)))))
        (Wt.app (ihb rb) (iha ra)) hBa
  case mty ih => cases r; exact Wt.mty (ih (parRefl _))
  case exf hA _ ihA ihb => cases r with | exf rA rb =>
    exact Wt.conv
      (convEqv (convSym (parConv rA)))
      (Wt.exf (ihA rA) (ihb rb)) hA
  case lvl hj iha _ => cases r with | lvl r' => exact Wt.lvl (iha r') hj
  case lof => cases r; constructor <;> assumption
  case trans hj ihi _ => exact Wt.trans (ihi r) hj
  case conv e _ hB iha _ => exact Wt.conv e (iha r) hB
  case sub hj _ _ ihA => exact Wt.sub hj (ihA r)

theorem wtPars {Œì} {a b A : Term} (r : a ‚áí‚ãÜ b) (h : Œì ‚ä¢ a ‚à∂ A) : Œì ‚ä¢ b ‚à∂ A := by
  induction r
  case refl => exact h
  case trans r _ ih => exact ih (wtPar r h)

/-*---------
  Progress
---------*-/

-- This needs to be in Type, not Prop
-- for the large elim in valueType
inductive Value : Term ‚Üí Type where
  | ùí∞ {k} : Value (ùí∞ k)
  | pi {a b} : Value (pi a b)
  | abs {a b} : Value (abs a b)
  | mty : Value mty
  | lvl {k} : Value (lvl k)
  | lof {k} : Value (lof k)

section
set_option hygiene false
local infix:40 "‚áíŒ≤" => CBN
local infix:40 "‚áíŒ≤‚ãÜ" => CBNs

inductive CBN : Term ‚Üí Term ‚Üí Prop where
  | Œ≤ {b a c} : app (abs c b) a ‚áíŒ≤ subst (a +: var) b
  | app {b b' a} : b ‚áíŒ≤  b' ‚Üí app b a ‚áíŒ≤ app b' a
  | exf {a b b'} : b ‚áíŒ≤ b' ‚Üí exf a b ‚áíŒ≤ exf a b'

inductive CBNs : Term ‚Üí Term ‚Üí Prop where
  | refl a : a ‚áíŒ≤‚ãÜ a
  | trans {a b c} : a ‚áíŒ≤ b ‚Üí b ‚áíŒ≤‚ãÜ c ‚Üí a ‚áíŒ≤‚ãÜ c
end

infix:40 "‚áíŒ≤" => CBN
infix:40 "‚áíŒ≤‚ãÜ" => CBNs

theorem CBNpar {a b} : a ‚áíŒ≤ b ‚Üí a ‚áí b
  | CBN.Œ≤ => Par.Œ≤ (parRefl _) (parRefl _)
  | CBN.app rb => Par.app (CBNpar rb) (parRefl _)
  | CBN.exf rb => Par.exf (parRefl _) (CBNpar rb)

@[simp] -- Shape of types of canonical values
def valueType {a} (A : Term) : Value a ‚Üí Prop
  | Value.ùí∞ | Value.pi | Value.mty | Value.lvl => ‚àÉ k, ùí∞ k ‚âà A
  | Value.abs => ‚àÉ B C, pi B C ‚âà A
  | Value.lof => ‚àÉ k, lvl k ‚âà A

-- The types of canonical values have the given shape
theorem wtValue {Œì} {a A B : Term} (h : Œì ‚ä¢ a ‚à∂ A) (e : A ‚âà B) : (v : Value a) ‚Üí valueType B v
  | Value.ùí∞ => let ‚ü®_, eùí∞‚ü© := wtfùí∞Inv h; ‚ü®_, Eqv.trans eùí∞ e‚ü©
  | Value.pi => let ‚ü®_, eùí∞‚ü© := wtfPiInvùí∞ h; ‚ü®_, Eqv.trans eùí∞ e‚ü©
  | Value.abs => let ‚ü®_, _, _, _, epi‚ü© := wtfAbsInv h; ‚ü®_, _, Eqv.trans epi e‚ü©
  | Value.mty => let ‚ü®_, eùí∞‚ü© := wtfMtyInv h; ‚ü®_, Eqv.trans eùí∞ e‚ü©
  | Value.lvl => let ‚ü®_, _, _, eùí∞‚ü© := wtfLvlInv h; ‚ü®_, Eqv.trans eùí∞ e‚ü©
  | Value.lof => let ‚ü®_, elvl‚ü© := wtfLofInv h; ‚ü®_, Eqv.trans elvl e‚ü©

theorem wtAbs {Œì} {b A B : Term} (v : Value b) (h : Œì ‚ä¢ b ‚à∂ pi A B) : ‚àÉ a' b', b = abs a' b' := by
  generalize e : pi A B = T at h
  induction h using wtInd
  all_goals try first | subst e | injection e
  case var | app | exf => contradiction
  case abs => exact ‚ü®_, _, rfl‚ü©
  case conv h v epi _ _ =>
    let _e := wtValue h epi v
    cases v <;> let ‚ü®_, e‚ü© := _e
    case ùí∞ | pi | mty | lvl => cases convùí∞Pi (eqvConv e)
    case abs => exact ‚ü®_, _, rfl‚ü©
    case lof => cases convLvlPi (eqvConv e)

theorem wtMty {Œì} {b : Term} (v : Value b) (h : Œì ‚ä¢ b ‚à∂ mty) : False := by
  generalize e : mty = T at h
  induction h using wtInd
  all_goals try first | subst e | injection e
  case var | app | exf => contradiction
  case conv h v emty _ _ =>
    let _e := wtValue h emty v
    cases v <;> let ‚ü®_, e‚ü© := _e
    case ùí∞ | pi | mty | lvl => cases convùí∞Mty (eqvConv e)
    case abs => let ‚ü®_, e‚ü© := e; cases convMtyPi (eqvConv (Eqv.sym e))
    case lof => cases convLvlMty (eqvConv e)

theorem wtProgress {a A : Term} (h : ‚¨ù ‚ä¢ a ‚à∂ A) : Nonempty (Value a) ‚à® ‚àÉ b, a ‚áíŒ≤ b := by
  generalize e : (‚¨ù) = Œì at h
  induction h using wtInd
  all_goals subst e; specialize_rfls
  case var mem => cases mem
  case ùí∞ | pi | abs | mty | lvl | lof => repeat constructor
  case trans ih _ | conv ih _ | sub ih => exact ih
  case app hb _ ihb _ =>
    cases ihb
    case inl v =>
      cases v with | intro v =>
      let ‚ü®_, _, e‚ü© := wtAbs v hb; subst e
      exact Or.inr ‚ü®_, CBN.Œ≤‚ü©
    case inr r => let ‚ü®_, r‚ü© := r; exact Or.inr ‚ü®_, CBN.app r‚ü©
  case exf _ hb _ ihb =>
    cases ihb
    case inl v => cases v with | intro v => cases wtMty v hb
    case inr r => let ‚ü®_, r‚ü© := r; exact Or.inr ‚ü®_, CBN.exf r‚ü©

/-*-------
  Safety
-------*-/

theorem wtSafety {a b A : Term} (h : ‚¨ù ‚ä¢ a ‚à∂ A) (r : a ‚áíŒ≤‚ãÜ b) :
  Nonempty (Value b) ‚à® ‚àÉ c, b ‚áíŒ≤ c := by
  induction r
  case refl => exact wtProgress h
  case trans r _ ih => exact ih (wtPar (CBNpar r) h)

\documentclass[a4paper,UKenglish,cleveref,autoref,thm-restate]{lipics-v2021}

% \pdfoutput=1
% \hideLIPIcs

\usepackage[supertabular]{ottalt}
\let\newlist\relax
\let\renewlist\relax
\usepackage{enumitem,xspace,doi}
\usepackage{mathpartir,mathtools,stmaryrd}
\usepackage[flushmargin,multiple,para]{footmisc} % para spacing is weird and ugly

\newcommand{\citep}[1]{\cite{#1}}
\newcommand{\citet}[1]{\cite{#1}}
\newcommand{\publicrepo}{\url{https://github.com/ionathanch/TT-model}}
\newcommand{\lang}{\textsf{TT}\@\xspace}
\newcommand{\titlebreak}{\texorpdfstring{\\}{}}
\newcommand{\ie}{\textit{i.e.}\@\xspace}
\newcommand{\eg}{\textit{e.g.}\@\xspace}
\newcommand{\etal}{\textit{et al.}\@\xspace}
\newcommand{\vs}{\textit{vs.}\@\xspace}
\newcommand{\welltyped}{well-\hspace{0pt}typed\@\xspace}
\newcommand{\wellfounded}{well-\hspace{0pt}founded\@\xspace}
\newcommand{\wellfoundedness}{well-\hspace{0pt}foundedness\@\xspace}
\newcommand{\wellformedness}{well-\hspace{0pt}formedness\@\xspace}
\newcommand{\welldefinedness}{well-\hspace{0pt}definedness\@\xspace}
\newcommand{\crude}{crude-\hspace{0pt}but-\hspace{0pt}effective\@\xspace}

\newcommand{\footfile}[1]{%
  \raggedright
  \href{\publicrepo{}/tree/main/TT-model/#1}{\texttt{#1}}
}
\newcommand{\footfilethm}[2]{%
  \raggedright
  \href{\publicrepo{}/tree/main/TT-model/#1}{\texttt{#1}}\texttt{:#2}
}

\setlength{\fboxsep}{1.5pt}

\newlength{\punctwidth}
% \nspace{<punct>} is a negative space the size of <punct>
\newcommand{\nspace}[1]{%
  \settowidth{\punctwidth}{#1}%
  \hspace*{-\the\punctwidth}%
}
% \npunct{<punct>} treats <punct> as having no width,
% so that footnotes after it can stack on top
\newcommand{\npunct}[1]{#1%
  \nspace{#1}%
}
% \nsup{<sup>}{<punct>} shifts <punct> left by
% the width of <sup> as a superscript
% so that footnotes *before* it will stack on top
\newcommand{\nsup}[2]{%
  \nspace{$^{#1}$}%
  #2%
}

\setlength{\fboxsep}{2pt}
\setlength{\abovecaptionskip}{0.5\baselineskip}

\hypersetup{
  colorlinks=true,
  urlcolor=blue,
  citecolor=magenta
}
\urlstyle{tt}

\title{Bounded First-Class Universe Levels \titlebreak in Type Theory}
\titlerunning{Bounded First-Class Universe Levels}
\authorrunning{J. Chan, S. Weirich}
\Copyright{Jonathan Chan, Stephanie Weirich}
\ccsdesc{Theory of computation~Type theory}
\keywords{type theory, universes, universe polymorphism}
\hideLIPIcs

\author{Jonathan Chan}
  {University of Pennsylvania, Philadelphia, USA}
  {jcxz@seas.upenn.edu}
  {0000-0003-0830-3180}
  {}

\author{Stephanie Weirich}
  {University of Pennsylvania, Philadelphia, USA}
  {sweirich@seas.upenn.edu}
  {0000-0002-6756-9168}
  {}

\supplementdetails[subcategory={source code},
  swhid={swh:1:dir:} % see https://www.softwareheritage.org/
]{Software}{https://github.com/ionathanch/TT-model}

\inputott{rules}

\acknowledgements{hi \href{https://types.pl}{\texttt{types.pl}}!}

\begin{document}

\maketitle

\begin{abstract}
  abstract
\end{abstract}

\section{Introduction}

\subsection{Comparison to other work}

\section{A basic type theory with bounded first-class universe levels}

We consider with a Curry-style type theory \`a la Russell,
where terms have no type annotations,
and there is no separate typing judgement for well-formedness of types.
To keep the type theory minimal, it contains only dependent functions,
an empty type, predicative universes, and bounded universe levels.
By convention, we use $\ottnt{a}, \ottnt{b}, \ottnt{c}$ for terms,
$\ottnt{A}, \ottnt{B}, \ottnt{C}$ for types,
and $\ottnt{k}, \ell$ for level terms.
The syntax is presented in nominally in \cref{fig:syntax},
although the mechanization uses de Bruijn indexing.
We write single substitution of a variable $\ottmv{x}$ in a term $\ottnt{b}$ by another term $\ottnt{a}$
as $ \ottnt{b} [  \ottmv{x}  \mapsto  \ottnt{a}  ] $.
We also use $ \ottnt{A}  \to  \ottnt{B} $ as sugar for nondependent functions
$ \Pi  \ottmv{x}  \mathbin{:}  \ottnt{A}  \mathpunct{.}  \ottnt{B} $ where $\ottmv{x}$ does not occur in $\ottnt{B}$.

\begin{figure}
\begin{align*}
  i, j & \Coloneqq \texttt{<external universe levels>} \\
  x, y, z & \Coloneqq \texttt{<term variables>} \\
  a, b, c, A, B, C, k, \ell & \Coloneqq \ottmv{x} \mid \ottmv{i}
    \mid  \Pi  \ottmv{x}  \mathbin{:}  \ottnt{A}  \mathpunct{.}  \ottnt{B}  \mid  \lambda  \ottmv{x}  \mathpunct{.}  \ottnt{b}  \mid  \ottnt{b}  \gap  \ottnt{a} 
    \mid  \bot  \mid  \kw{absurd} \gap  \ottnt{b} 
    \mid  \kw{U} \gap  \ottnt{k}  \mid  \kw{Level}\texttt{<} \gap  \ell  \\
  \Gamma, \Delta & \Coloneqq  \cdot  \mid  \Gamma ,  \ottmv{x}  \mathbin{:}  \ottnt{A} 
\end{align*}
\caption{Syntax}
\label{fig:syntax}
\end{figure}

The type theory is parametrized over a cofinal woset of levels,
\ie a set of levels that are well founded, totally ordered,
and each have some strictly larger level;
these properties are required when modelling the type theory.
Instances of such sets include the naturals $0, 1, 2, \dots$,
as well as the naturals extended by one limit ordinal $\omega$
and its successors $\omega + 1, \omega + 2, \dots$.
We continue to use these concrete levels for our examples.
These metalevel levels are internalized directly in system as terms $\ottmv{i}$.

\begin{figure}
\begin{mathpar}
  \fbox{$ \mathop{\vdash}  \Gamma $} \qquad \fbox{$ \Gamma  \vdash  \ottnt{a}  \mathrel{:}  \ottnt{A} $} \qquad \fbox{$ \ottnt{a}  =  \ottnt{b} $} \hfill \\
  \inferrule[\ottdrulename{Nil}]{~}{ \mathop{\vdash}   \cdot  }
  \and
  \inferrule[\ottdrulename{Cons}]
    { \mathop{\vdash}  \Gamma  \and
      \Gamma  \vdash  \ottnt{A}  \mathrel{:}   \kw{U} \gap  \ottnt{k}  }
    %------------------%
    { \mathop{\vdash}   \Gamma ,  \ottmv{x}  \mathbin{:}  \ottnt{A}  }
  \and
  \inferrule[\ottdrulename{Var}]
    { \mathop{\vdash}  \Gamma  \and
      \ottmv{x}  \mathrel{:}  \ottnt{A}  \in  \Gamma }
    %-------------%
    { \Gamma  \vdash  \ottmv{x}  \mathrel{:}  \ottnt{A} }
  \and
  \inferrule[\ottdrulename{Pi}]
    { \Gamma  \vdash  \ottnt{A}  \mathrel{:}   \kw{U} \gap  \ottnt{k}   \and
       \Gamma ,  \ottmv{x}  \mathbin{:}  \ottnt{A}   \vdash  \ottnt{B}  \mathrel{:}   \kw{U} \gap  \ottnt{k}  }
    %--------------------------%
    { \Gamma  \vdash   \Pi  \ottmv{x}  \mathbin{:}  \ottnt{A}  \mathpunct{.}  \ottnt{B}   \mathrel{:}   \kw{U} \gap  \ottnt{k}  }
  \and
  \inferrule[\ottdrulename{Lam}]
    { \Gamma  \vdash   \Pi  \ottmv{x}  \mathbin{:}  \ottnt{A}  \mathpunct{.}  \ottnt{B}   \mathrel{:}   \kw{U} \gap  \ottnt{k}   \and
       \Gamma ,  \ottmv{x}  \mathbin{:}  \ottnt{A}   \vdash  \ottnt{b}  \mathrel{:}  \ottnt{B} }
    %-------------------------%
    { \Gamma  \vdash   \lambda  \ottmv{x}  \mathpunct{.}  \ottnt{b}   \mathrel{:}   \Pi  \ottmv{x}  \mathbin{:}  \ottnt{A}  \mathpunct{.}  \ottnt{B}  }
  \and
  \inferrule[\ottdrulename{App}]
    { \Gamma  \vdash  \ottnt{b}  \mathrel{:}   \Pi  \ottmv{x}  \mathbin{:}  \ottnt{A}  \mathpunct{.}  \ottnt{B}   \and
      \Gamma  \vdash  \ottnt{a}  \mathrel{:}  \ottnt{A} }
    %----------------------%
    { \Gamma  \vdash   \ottnt{b}  \gap  \ottnt{a}   \mathrel{:}   \ottnt{B} [  \ottmv{x}  \mapsto  \ottnt{a}  ]  }
  \and
  \inferrule[\ottdrulename{Mty}]
    { \Gamma  \vdash   \kw{U} \gap  \ottnt{k}   \mathrel{:}   \kw{U} \gap  \ell  }
    %-----------------------%
    { \Gamma  \vdash   \bot   \mathrel{:}   \kw{U} \gap  \ottnt{k}  }
  \and
  \inferrule[\ottdrulename{Abs}]
    { \Gamma  \vdash  \ottnt{A}  \mathrel{:}   \kw{U} \gap  \ottnt{k}   \and
      \Gamma  \vdash  \ottnt{b}  \mathrel{:}   \bot  }
    %-----------------%
    { \Gamma  \vdash   \kw{absurd} \gap  \ottnt{b}   \mathrel{:}  \ottnt{A} }
  \and
  \inferrule[\ottdrulename{Conv}]
    { \Gamma  \vdash  \ottnt{a}  \mathrel{:}  \ottnt{A}  \and
      \Gamma  \vdash  \ottnt{B}  \mathrel{:}   \kw{U} \gap  \ottnt{k}   \and
      \ottnt{A}  =  \ottnt{B} }
    %------------------%
    { \Gamma  \vdash  \ottnt{a}  \mathrel{:}  \ottnt{B} }
\end{mathpar}
%
\begin{mathpar}
  \inferrule[\ottdrulename{E-Beta}]{~}{   (  \lambda  \ottmv{x}  \mathpunct{.}  \ottnt{b}  )   \gap  \ottnt{a}   =   \ottnt{b} [  \ottmv{x}  \mapsto  \ottnt{a}  ]  } \and
  \inferrule[\ottdrulename{E-Refl}]{~}{ \ottnt{a}  =  \ottnt{a} } \and
  \inferrule[\ottdrulename{E-Sym}]{ \ottnt{a}  =  \ottnt{b} }{ \ottnt{b}  =  \ottnt{a} } \and
  \inferrule[\ottdrulename{E-Trans}]{ \ottnt{a}  =  \ottnt{b}  \and  \ottnt{b}  =  \ottnt{c} }{ \ottnt{a}  =  \ottnt{c} } \and
  \cdots
\end{mathpar}

\caption{Typing and selected equality rules (no universes or levels)}
\label{fig:typing:basic}
\end{figure}

We begin first with the basic rules that don't concern universes or levels in \cref{fig:typing:basic},
consisting of a context well-formedness judgement $ \mathop{\vdash}  \Gamma $,
a typing judgement $ \Gamma  \vdash  \ottnt{a}  \mathrel{:}  \ottnt{A} $, and an untyped definitional equality $ \ottnt{a}  =  \ottnt{b} $.
\Rref{Lam} explicitly includes well-typedness of a function's type as a premise
rather than merely well-typedness of the domain type $\ottnt{A}$
to guarantee that it lives at the same universe level as the codomain type $\ottnt{B}$,
which we need to prove our fundamental theorem.
The remaining rules are otherwise as expected.
We use $\beta$-conversion as our definitional equality,
and omit the usual congruence rules.

\begin{figure}
\begin{mathpar}
  \inferrule[\ottdrulename{Univ}]
    { \Gamma  \vdash  \ottnt{k}  \mathrel{:}   \kw{Level}\texttt{<} \gap  \ell  }
    %-----------------------%
    { \Gamma  \vdash   \kw{U} \gap  \ottnt{k}   \mathrel{:}   \kw{U} \gap  \ell  }
  \and
  \inferrule[\ottdrulename{Level<}]
    { \Gamma  \vdash   \kw{U} \gap  \ottnt{k_{{\mathrm{1}}}}   \mathrel{:}   \kw{U} \gap  \ell_{{\mathrm{1}}}   \and
      \Gamma  \vdash  \ottnt{k_{{\mathrm{0}}}}  \mathrel{:}   \kw{Level}\texttt{<} \gap  \ell_{{\mathrm{0}}}  }
    %---------------------------%
    { \Gamma  \vdash   \kw{Level}\texttt{<} \gap  \ottnt{k_{{\mathrm{0}}}}   \mathrel{:}   \kw{U} \gap  \ottnt{k_{{\mathrm{1}}}}  }
  \and
  \inferrule[\ottdrulename{Lvl}]
    { \mathop{\vdash}  \Gamma  \and
      \ottmv{i}  <  \ottmv{j} }
    %--------------------%
    { \Gamma  \vdash   \ottmv{i}   \mathrel{:}   \kw{Level}\texttt{<} \gap   \ottmv{j}   }
  \and
  \inferrule[\ottdrulename{Trans}]
    { \Gamma  \vdash  \ottnt{k_{{\mathrm{1}}}}  \mathrel{:}   \kw{Level}\texttt{<} \gap  \ottnt{k_{{\mathrm{2}}}}   \and
      \Gamma  \vdash  \ottnt{k_{{\mathrm{2}}}}  \mathrel{:}   \kw{Level}\texttt{<} \gap  \ottnt{k_{{\mathrm{3}}}}  }
    %----------------------%
    { \Gamma  \vdash  \ottnt{k_{{\mathrm{1}}}}  \mathrel{:}   \kw{Level}\texttt{<} \gap  \ottnt{k_{{\mathrm{3}}}}  }
  \and
  \inferrule[\ottdrulename{Sub}]
    { \Gamma  \vdash  \ottnt{A}  \mathrel{:}   \kw{U} \gap  \ottnt{k}   \and
      \Gamma  \vdash  \ottnt{k}  \mathrel{:}   \kw{Level}\texttt{<} \gap  \ell  }
    %--------------------%
    { \Gamma  \vdash  \ottnt{A}  \mathrel{:}   \kw{U} \gap  \ell  }
\end{mathpar}
\caption{Typing rules (universes and levels)}
\label{fig:typing:univ}
\end{figure}

The rules relating to universes and levels are given in \cref{fig:typing:univ}.
By \rref{Lvl}, we can view the type constructor $ \kw{Level}\texttt{<} \gap   \relax  $
as the internalization of the order on levels.
As the level type is combined with level bounding,
it is impossible to declare a level variable strictly less than itself.
The level type itself can be typed at any universe
regardless of what the bounding level is.
For example, we can construct a derivation for $  \cdot   \vdash   \kw{Level}\texttt{<} \gap   2    \mathrel{:}   \kw{U} \gap   0   $
solely knowing that $  \cdot   \vdash   2   \mathrel{:}   \kw{Level}\texttt{<} \gap   3   $ and $  \cdot   \vdash   \kw{U} \gap   0    \mathrel{:}   \kw{U} \gap   1   $.

\Rref{Trans} internalizes transitivity of the order on levels,
which is now required since levels are terms in general and not only concrete levels.
For example, we can construct a derivation for $   \ottmv{x}  \mathbin{:}   \kw{Level}\texttt{<} \gap   \omega    ,  \ottmv{y}  \mathbin{:}   \kw{Level}\texttt{<} \gap  \ottmv{x}    \vdash  \ottmv{x}  \mathrel{:}   \kw{Level}\texttt{<} \gap   \omega   $,
where the levels $\ottmv{x}, \ottmv{y}$ are variables.

\Rref{Sub} is a subsumption rule that permits lifting a type
from one universe to a higher universe.
This rule is weaker than a full cumulativity rule that accounts for
contravariance in the domain and covariance in the codomain of function types.
Therefore, for instance, $  \ottmv{f}  \mathbin{:}    \kw{U} \gap   2    \to   \kw{U} \gap   0      \vdash  \ottmv{f}  \mathrel{:}    \kw{U} \gap   1    \to   \kw{U} \gap   1    $ does \emph{not} hold.
Nonetheless, subsumption allows us to instead type the $\eta$-expansion
$  \ottmv{f}  \mathbin{:}    \kw{U} \gap   2    \to   \kw{U} \gap   0      \vdash    \lambda  \ottmv{x}  \mathpunct{.}  \ottmv{f}   \gap  \ottmv{x}   \mathrel{:}    \kw{U} \gap   1    \to   \kw{U} \gap   1    $.

Finally, \rref{Univ} asserts that a universe at level $\ottnt{k}$
lives in the universe at level $\ell$ when $\ottnt{k}$ is strictly bounded by $\ell$.
Allowing universes with general level terms and not just concrete levels
to be well typed is what permits typing level-polymorphic types.
For example, we can derive a typing judgement for
the following level-polymorphic identity function type:
$$  \cdot   \vdash    \Pi  \ottmv{x}  \mathbin{:}   \kw{Level}\texttt{<} \gap   \omega    \mathpunct{.}   \Pi  \ottmv{y}  \mathbin{:}   \kw{U} \gap  \ottmv{x}   \mathpunct{.}  \ottmv{y}    \to  \ottmv{y}   \mathrel{:}   \kw{U} \gap   \omega   $$
$ \kw{Level}\texttt{<} \gap   \omega  $ can be assigned an arbitrary type by \rref{Level},
$ \kw{U} \gap  \ottmv{x} $ has type $ \kw{U} \gap   \omega  $ by \rref{Univ} and \rref{Var},
and $\ottmv{y}$ can be assigned type $ \kw{U} \gap   \omega  $ transitively
via \rref{Trans,Var}.
Then the entire term has type $ \kw{U} \gap   \omega  $ by repeated application of \rref{Pi}.

\section{Metatheory}

\subsection{Type safety}

\subsection{Consistency and canonicity}

\begin{figure}
\begin{mathpar}
  \inferrule[\ottdrulename{I-Univ}]
    { \ottmv{j}  <  \ottmv{i} }
    %---------------------------------------%
  { \mathopen{\llbracket}   \kw{U} \gap   \ottmv{j}    \mathclose{\rrbracket}_{ \ottmv{i} } \searrow   \lbrace  \ottmv{z}  \mid   \exists  \ottnt{P}  \mathpunct{.}   \mathopen{\llbracket}  \ottmv{z}  \mathclose{\rrbracket}_{ \ottmv{j} } \searrow  \ottnt{P}    \rbrace  }
  \and
  \inferrule[\ottdrulename{I-Pi}]
    { \mathopen{\llbracket}  \ottnt{A}  \mathclose{\rrbracket}_{ \ottmv{i} } \searrow  \ottnt{P_{{\mathrm{1}}}}  \and
       \forall  \ottmv{y}  \mathpunct{.}   \ottmv{y}  \in  \ottnt{P_{{\mathrm{1}}}}    \to   \exists  \ottnt{P_{{\mathrm{2}}}}  \mathpunct{.}   \ottnt{R} ( \ottmv{y} ,  \ottnt{P_{{\mathrm{2}}}} )    \and
       \forall  \ottmv{y}  \mathpunct{.}   \forall  \ottnt{P_{{\mathrm{2}}}}  \mathpunct{.}   \ottnt{R} ( \ottmv{y} ,  \ottnt{P_{{\mathrm{2}}}} )     \to   \mathopen{\llbracket}   \ottnt{B} [  \ottmv{x}  \mapsto  \ottmv{y}  ]   \mathclose{\rrbracket}_{ \ottmv{i} } \searrow  \ottnt{P_{{\mathrm{2}}}}  }
    %--------------------------------------------------------------------------------%
    { \mathopen{\llbracket}   \Pi  \ottmv{x}  \mathbin{:}  \ottnt{A}  \mathpunct{.}  \ottnt{B}   \mathclose{\rrbracket}_{ \ottmv{i} } \searrow   \lbrace  \ottmv{f}  \mid   \forall  \ottmv{y}  \mathpunct{.}    \forall  \ottnt{P_{{\mathrm{2}}}}  \mathpunct{.}    \ottnt{R} ( \ottmv{y} ,  \ottnt{P_{{\mathrm{2}}}} )   \to   \ottmv{y}  \in  \ottnt{P_{{\mathrm{1}}}}     \to    \ottmv{f}  \gap  \ottmv{y}   \in  \ottnt{P_{{\mathrm{2}}}}     \rbrace  }
  \and
  \inferrule[\ottdrulename{I-Pi'}]
    { \mathopen{\llbracket}  \ottnt{A}  \mathclose{\rrbracket}_{ \ottmv{i} } \searrow  \ottnt{P_{{\mathrm{1}}}}  \and
       \forall  \ottmv{y}  \mathpunct{.}   \ottmv{y}  \in  \ottnt{P_{{\mathrm{1}}}}    \to   \exists  \ottnt{P_{{\mathrm{2}}}}  \mathpunct{.}   \mathopen{\llbracket}   \ottnt{B} [  \ottmv{x}  \mapsto  \ottmv{y}  ]   \mathclose{\rrbracket}_{ \ottmv{i} } \searrow  \ottnt{P_{{\mathrm{2}}}}   }
    %--------------------------------------------------------------------------------%
    { \mathopen{\llbracket}   \Pi  \ottmv{x}  \mathbin{:}  \ottnt{A}  \mathpunct{.}  \ottnt{B}   \mathclose{\rrbracket}_{ \ottmv{i} } \searrow   \lbrace  \ottmv{f}  \mid   \forall  \ottmv{y}  \mathpunct{.}    \forall  \ottnt{P_{{\mathrm{2}}}}  \mathpunct{.}    (  \mathopen{\llbracket}   \ottnt{B} [  \ottmv{x}  \mapsto  \ottmv{y}  ]   \mathclose{\rrbracket}_{ \ottmv{i} } \searrow  \ottnt{P_{{\mathrm{2}}}}  )   \to   \ottmv{y}  \in  \ottnt{P_{{\mathrm{1}}}}     \to    \ottmv{f}  \gap  \ottmv{y}   \in  \ottnt{P_{{\mathrm{2}}}}     \rbrace  }
  \and
  \inferrule[\ottdrulename{I-Mty}]{~}
    { \mathopen{\llbracket}   \bot   \mathclose{\rrbracket}_{ \ottmv{i} } \searrow   \varnothing  }
  \and
  \inferrule[\ottdrulename{I-Level<}]{~}
    { \mathopen{\llbracket}   \kw{Level}\texttt{<} \gap   \ottmv{j_{{\mathrm{1}}}}    \mathclose{\rrbracket}_{ \ottmv{i} } \searrow   \lbrace  \ottmv{z}  \mid   \exists  \ottmv{j_{{\mathrm{2}}}}  \mathpunct{.}    \ottmv{z}  \Rightarrow^\ast   \ottmv{j_{{\mathrm{2}}}}    \wedge   \ottmv{j_{{\mathrm{1}}}}  <  \ottmv{j_{{\mathrm{2}}}}     \rbrace  }
  \and
  \inferrule[\ottdrulename{I-Step}]
    { \ottnt{A}  \Rightarrow  \ottnt{B}  \and
      \mathopen{\llbracket}  \ottnt{B}  \mathclose{\rrbracket}_{ \ottmv{i} } \searrow  \ottnt{P} }
     %--------------%
    { \mathopen{\llbracket}  \ottnt{A}  \mathclose{\rrbracket}_{ \ottmv{i} } \searrow  \ottnt{P} }
\end{mathpar}
\caption{Logical relation for closed types}
\label{fig:lr:closed}
\end{figure}

\subsection{Attempts at proving normalization}

\section{Conclusion and future work}

\subsection{Extensions}

\citet{gen-univ,univ-poly}

\bibliographystyle{plainurl}
\bibliography{main.bib}

\end{document}
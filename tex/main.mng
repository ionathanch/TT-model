\documentclass[a4paper,UKenglish,cleveref,autoref,thm-restate]{lipics-v2021}

% \pdfoutput=1
% \hideLIPIcs

\usepackage[supertabular]{ottalt}
\let\newlist\relax
\let\renewlist\relax
\usepackage{enumitem,xspace,doi}
\usepackage{mathpartir,mathtools,stmaryrd}
\usepackage[flushmargin,multiple,para]{footmisc} % para spacing is weird and ugly

\newcommand{\citep}[1]{\cite{#1}}
\newcommand{\citet}[1]{\cite{#1}}
\newcommand{\publicrepo}{\url{https://github.com/ionathanch/TT-model}}
\newcommand{\lang}{\textsf{TT}\@\xspace}
\newcommand{\titlebreak}{\texorpdfstring{\\}{}}
\newcommand{\ie}{\textit{i.e.}\@\xspace}
\newcommand{\eg}{\textit{e.g.}\@\xspace}
\newcommand{\etal}{\textit{et al.}\@\xspace}
\newcommand{\vs}{\textit{vs.}\@\xspace}
\newcommand{\welltyped}{well-\hspace{0pt}typed\@\xspace}
\newcommand{\wellfounded}{well-\hspace{0pt}founded\@\xspace}
\newcommand{\wellfoundedness}{well-\hspace{0pt}foundedness\@\xspace}
\newcommand{\wellformedness}{well-\hspace{0pt}formedness\@\xspace}
\newcommand{\welldefinedness}{well-\hspace{0pt}definedness\@\xspace}
\newcommand{\crude}{crude-\hspace{0pt}but-\hspace{0pt}effective\@\xspace}

\newcommand{\footfile}[1]{%
  \raggedright
  \href{\publicrepo{}/tree/main/TT-model/#1}{\texttt{#1}}
}
\newcommand{\footfilethm}[2]{%
  \raggedright
  \href{\publicrepo{}/tree/main/TT-model/#1}{\texttt{#1}}\texttt{:#2}
}

\setlength{\fboxsep}{1.5pt}

\newlength{\punctwidth}
% \nspace{<punct>} is a negative space the size of <punct>
\newcommand{\nspace}[1]{%
  \settowidth{\punctwidth}{#1}%
  \hspace*{-\the\punctwidth}%
}
% \npunct{<punct>} treats <punct> as having no width,
% so that footnotes after it can stack on top
\newcommand{\npunct}[1]{#1%
  \nspace{#1}%
}
% \nsup{<sup>}{<punct>} shifts <punct> left by
% the width of <sup> as a superscript
% so that footnotes *before* it will stack on top
\newcommand{\nsup}[2]{%
  \nspace{$^{#1}$}%
  #2%
}

\setlength{\fboxsep}{2pt}
\setlength{\abovecaptionskip}{0.5\baselineskip}

\hypersetup{
  colorlinks=true,
  urlcolor=blue,
  citecolor=magenta
}
\urlstyle{tt}

\title{Bounded First-Class Universe Levels \titlebreak in Type Theory}
\titlerunning{Bounded First-Class Universe Levels}
\authorrunning{J. Chan, S. Weirich}
\Copyright{Jonathan Chan, Stephanie Weirich}
\ccsdesc{Theory of computation~Type theory}
\keywords{type theory, universes, universe polymorphism}
\hideLIPIcs

\author{Jonathan Chan}
  {University of Pennsylvania, Philadelphia, USA}
  {jcxz@seas.upenn.edu}
  {0000-0003-0830-3180}
  {}

\author{Stephanie Weirich}
  {University of Pennsylvania, Philadelphia, USA}
  {sweirich@seas.upenn.edu}
  {0000-0002-6756-9168}
  {}

\supplementdetails[subcategory={source code},
  swhid={swh:1:dir:} % see https://www.softwareheritage.org/
]{Software}{https://github.com/ionathanch/TT-model}

\inputott{rules}

\acknowledgements{hi \href{https://types.pl}{\texttt{types.pl}}!}

\begin{document}

\maketitle

\begin{abstract}
  abstract
\end{abstract}

\section{Introduction}

\subsection{Comparison to other work}

\section{A basic type theory with bounded first-class universe levels}

We consider with a Curry-style type theory \`a la Russell,
where terms have no type annotations,
and there is no separate typing judgement for well-formedness of types.
To keep the type theory minimal, it contains only dependent functions,
an empty type, predicative universes, and bounded universe levels.
By convention, we use $[[a]], [[b]], [[c]]$ for terms,
$[[A]], [[B]], [[C]]$ for types,
and $[[k]], [[l]]$ for level terms.
The syntax is presented in nominally in \cref{fig:syntax},
although the mechanization uses de Bruijn indexing.
We write single substitution of a variable $[[x]]$ in a term $[[b]]$ by another term $[[a]]$
as $[[b{x ↦ a}]]$.
We also use $[[A → B]]$ as sugar for nondependent functions
$[[Πx : A. B]]$ where $[[x]]$ does not occur in $[[B]]$.

\begin{figure}
\begin{align*}
  i, j & \Coloneqq \texttt{<external universe levels>} \\
  x, y, z & \Coloneqq \texttt{<term variables>} \\
  a, b, c, A, B, C, k, \ell & \Coloneqq [[x]] \mid [[i]]
    \mid [[Πx : A. B]] \mid [[λx. b]] \mid [[b a]]
    \mid [[⊥]] \mid [[abs b]]
    \mid [[Type k]] \mid [[Level< l]] \\
  [[G]], [[D]] & \Coloneqq [[•]] \mid [[G, x : A]]
\end{align*}
\caption{Syntax}
\label{fig:syntax}
\end{figure}

The type theory is parametrized over a cofinal woset of levels,
\ie a set of levels that are well founded, totally ordered,
and each have some strictly larger level;
these properties are required when modelling the type theory.
Instances of such sets include the naturals $0, 1, 2, \dots$,
as well as the naturals extended by one limit ordinal $\omega$
and its successors $\omega + 1, \omega + 2, \dots$.
We continue to use these concrete levels for our examples.
These metalevel levels are internalized directly in system as terms $[[i]]$.

\begin{figure}
\begin{mathpar}
  \fbox{$[[⊢ G]]$} \qquad \fbox{$[[G ⊢ a : A]]$} \qquad \fbox{$[[a = b]]$} \hfill \\
  \inferrule[\ottdrulename{Nil}]{~}{[[⊢ •]]}
  \and
  \inferrule[\ottdrulename{Cons}]
    {[[⊢ G]] \and
     [[G ⊢ A : Type k]]}
    %------------------%
    {[[⊢ G, x : A]]}
  \and
  \inferrule[\ottdrulename{Var}]
    {[[⊢ G]] \and
     [[x : A ∈ G]]}
    %-------------%
    {[[G ⊢ x : A]]}
  \and
  \inferrule[\ottdrulename{Pi}]
    {[[G ⊢ A : Type k]] \and
     [[G, x : A ⊢ B : Type k]]}
    %--------------------------%
    {[[G ⊢ Πx : A. B : Type k]]}
  \and
  \inferrule[\ottdrulename{Lam}]
    {[[G ⊢ Πx : A. B : Type k]] \and
     [[G, x : A ⊢ b : B]]}
    %-------------------------%
    {[[G ⊢ λx. b : Πx : A. B]]}
  \and
  \inferrule[\ottdrulename{App}]
    {[[G ⊢ b : Πx : A. B]] \and
     [[G ⊢ a : A]]}
    %----------------------%
    {[[G ⊢ b a : B{x ↦ a}]]}
  \and
  \inferrule[\ottdrulename{Mty}]
    {[[G ⊢ Type k : Type l]]}
    %-----------------------%
    {[[G ⊢ ⊥ : Type k]]}
  \and
  \inferrule[\ottdrulename{Abs}]
    {[[G ⊢ A : Type k]] \and
     [[G ⊢ b : ⊥]]}
    %-----------------%
    {[[G ⊢ abs b : A]]}
  \and
  \inferrule[\ottdrulename{Conv}]
    {[[G ⊢ a : A]] \and
     [[G ⊢ B : Type k]] \and
     [[A = B]]}
    %------------------%
    {[[G ⊢ a : B]]}
\end{mathpar}
%
\begin{mathpar}
  \inferrule[\ottdrulename{E-Beta}]{~}{[[(λx. b) a = b{x ↦ a}]]} \and
  \inferrule[\ottdrulename{E-Refl}]{~}{[[a = a]]} \and
  \inferrule[\ottdrulename{E-Sym}]{[[a = b]]}{[[b = a]]} \and
  \inferrule[\ottdrulename{E-Trans}]{[[a = b]] \and [[b = c]]}{[[a = c]]} \and
  \cdots
\end{mathpar}

\caption{Typing and selected equality rules (no universes or levels)}
\label{fig:typing:basic}
\end{figure}

We begin first with the basic rules that don't concern universes or levels in \cref{fig:typing:basic},
consisting of a context well-formedness judgement $[[⊢ G]]$,
a typing judgement $[[G ⊢ a : A]]$, and an untyped definitional equality $[[a = b]]$.
\Rref{Lam} explicitly includes well-typedness of a function's type as a premise
rather than merely well-typedness of the domain type $[[A]]$
to guarantee that it lives at the same universe level as the codomain type $[[B]]$,
which we need to prove our fundamental theorem.
The remaining rules are otherwise as expected.
We use $\beta$-conversion as our definitional equality,
and omit the usual congruence rules.

\begin{figure}
\begin{mathpar}
  \inferrule[\ottdrulename{Univ}]
    {[[G ⊢ k : Level< l]]}
    %-----------------------%
    {[[G ⊢ Type k : Type l]]}
  \and
  \inferrule[\ottdrulename{Level<}]
    {[[G ⊢ Type k1 : Type l1]] \and
     [[G ⊢ k0 : Level< l0]]}
    %---------------------------%
    {[[G ⊢ Level< k0 : Type k1]]}
  \and
  \inferrule[\ottdrulename{Lvl}]
    {[[⊢ G]] \and
     [[i < j]]}
    %--------------------%
    {[[G ⊢ i : Level< j]]}
  \and
  \inferrule[\ottdrulename{Trans}]
    {[[G ⊢ k1 : Level< k2]] \and
     [[G ⊢ k2 : Level< k3]]}
    %----------------------%
    {[[G ⊢ k1 : Level< k3]]}
  \and
  \inferrule[\ottdrulename{Sub}]
    {[[G ⊢ A : Type k]] \and
     [[G ⊢ k : Level< l]]}
    %--------------------%
    {[[G ⊢ A : Type l]]}
\end{mathpar}
\caption{Typing rules (universes and levels)}
\label{fig:typing:univ}
\end{figure}

The rules relating to universes and levels are given in \cref{fig:typing:univ}.
By \rref{Lvl}, we can view the type constructor $[[Level< _]]$
as the internalization of the order on levels.
As the level type is combined with level bounding,
it is impossible to declare a level variable strictly less than itself.
The level type itself can be typed at any universe
regardless of what the bounding level is.
For example, we can construct a derivation for $[[• ⊢ Level< 2 : Type 0]]$
solely knowing that $[[• ⊢ 2 : Level< 3]]$ and $[[• ⊢ Type 0 : Type 1]]$.

\Rref{Trans} internalizes transitivity of the order on levels,
which is now required since levels are terms in general and not only concrete levels.
For example, we can construct a derivation for $[[x : Level< o, y : Level< x ⊢ x : Level< o]]$,
where the levels $[[x]], [[y]]$ are variables.

\Rref{Sub} is a subsumption rule that permits lifting a type
from one universe to a higher universe.
This rule is weaker than a full cumulativity rule that accounts for
contravariance in the domain and covariance in the codomain of function types.
Therefore, for instance, $[[f : Type 2 → Type 0 ⊢ f : Type 1 → Type 1]]$ does \emph{not} hold.
Nonetheless, subsumption allows us to instead type the $\eta$-expansion
$[[f : Type 2 → Type 0 ⊢ λx. f x : Type 1 → Type 1]]$.

Finally, \rref{Univ} asserts that a universe at level $[[k]]$
lives in the universe at level $[[l]]$ when $[[k]]$ is strictly bounded by $[[l]]$.
Allowing universes with general level terms and not just concrete levels
to be well typed is what permits typing level-polymorphic types.
For example, we can derive a typing judgement for
the following level-polymorphic identity function type:
$$[[• ⊢ Πx : Level< o. Πy : Type x. y → y : Type o]]$$
$[[Level< o]]$ can be assigned an arbitrary type by \rref{Level},
$[[Type x]]$ has type $[[Type o]]$ by \rref{Univ} and \rref{Var},
and $[[y]]$ can be assigned type $[[Type o]]$ transitively
via \rref{Trans,Var}.
Then the entire term has type $[[Type o]]$ by repeated application of \rref{Pi}.

\section{Metatheory}

\subsection{Type safety}

\subsection{Consistency and canonicity}

\begin{figure}
\begin{mathpar}
  \inferrule[\ottdrulename{I-Univ}]
    {[[j < i]]}
    %---------------------------------------%
  {[[⟦ Type j ⟧ i ↘ {z | ∃ P. ⟦ z ⟧ j ↘ P}]]}
  \and
  \inferrule[\ottdrulename{I-Pi}]
    {[[⟦ A ⟧ i ↘ P1]] \and
     [[∀ y. y ∈ P1 → ∃ P2. R(y, P2)]] \and
     [[∀ y. ∀ P2. R(y, P2) → ⟦ B{x ↦ y} ⟧ i ↘ P2]]}
    %--------------------------------------------------------------------------------%
    {[[⟦ Πx : A. B ⟧ i ↘ {f | ∀ y. ∀ P2. R(y, P2) → y ∈ P1 → f y ∈ P2}]]}
  \and
  \inferrule[\ottdrulename{I-Pi'}]
    {[[⟦ A ⟧ i ↘ P1]] \and
     [[∀ y. y ∈ P1 → ∃ P2. ⟦ B{x ↦ y} ⟧ i ↘ P2]]}
    %--------------------------------------------------------------------------------%
    {[[⟦ Πx : A. B ⟧ i ↘ {f | ∀ y. ∀ P2. (⟦ B{x ↦ y} ⟧ i ↘ P2) → y ∈ P1 → f y ∈ P2}]]}
  \and
  \inferrule[\ottdrulename{I-Mty}]{~}
    {[[⟦ ⊥ ⟧ i ↘ ∅]]}
  \and
  \inferrule[\ottdrulename{I-Level<}]{~}
    {[[⟦ Level< j1 ⟧ i ↘ {z | ∃ j2. z ⇒* j2 ∧ j1 < j2}]]}
  \and
  \inferrule[\ottdrulename{I-Step}]
    {[[A ⇒ B]] \and
     [[⟦ B ⟧ i ↘ P]]}
     %--------------%
    {[[⟦ A ⟧ i ↘ P]]}
\end{mathpar}
\caption{Logical relation for closed types}
\label{fig:lr:closed}
\end{figure}

\subsection{Attempts at proving normalization}

\section{Conclusion and future work}

\subsection{Extensions}

\citet{gen-univ,univ-poly}

\bibliographystyle{plainurl}
\bibliography{main.bib}

\end{document}
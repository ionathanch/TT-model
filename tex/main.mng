\documentclass[a4paper,UKenglish,cleveref,autoref,thm-restate]{lipics-v2021}

% \pdfoutput=1
% \hideLIPIcs

\usepackage[supertabular]{ottalt}
\let\newlist\relax
\let\renewlist\relax
\usepackage{enumitem,booktabs,xspace,doi}
\usepackage{mathpartir,mathtools,stmaryrd}
\usepackage[flushmargin,multiple,para]{footmisc} % para spacing is weird and ugly
\usepackage[outputdir=latex.out]{minted}
\usepackage{fontspec}
\setmonofont[Scale=MatchUppercase]{sgr-iosevka-fixed-regular.ttc}

\newcommand{\citep}[1]{\cite{#1}}
\newcommand{\citet}[1]{\cite{#1}}
\newcommand{\repo}{\url{https://github.com/ionathanch/TT-model}}
\newcommand{\lang}{\textsf{TTBFL}\@\xspace}
\newcommand{\titlebreak}{\texorpdfstring{\\}{}}
\newcommand{\ie}{\textit{i.e.}\@\xspace}
\newcommand{\eg}{\textit{e.g.}\@\xspace}
\newcommand{\etal}{\textit{et al.}\@\xspace}
\newcommand{\vs}{\textit{vs.}\@\xspace}
\newcommand{\apriori}{\textit{a priori}\@\xspace}
\newcommand{\fstar}{F$^\star$\@\xspace}
\newcommand{\welltyped}{well-\hspace{0pt}typed\@\xspace}
\newcommand{\wellfounded}{well-\hspace{0pt}founded\@\xspace}
\newcommand{\wellfoundedness}{well-\hspace{0pt}foundedness\@\xspace}
\newcommand{\wellformedness}{well-\hspace{0pt}formedness\@\xspace}
\newcommand{\welldefinedness}{well-\hspace{0pt}definedness\@\xspace}
\newcommand{\crude}{crude-\hspace{0pt}but-\hspace{0pt}effective\@\xspace}

\newcommand{\footfile}[1]{%
  \raggedright
  \href{\repo{}/tree/main/TT-model/#1}{\texttt{#1}}
}
\newcommand{\footfilethm}[2]{%
  \raggedright
  \href{\repo{}/tree/main/TT-model/#1}{\texttt{#1}}\texttt{:#2}
}

\newlength{\punctwidth}
% \nspace{<punct>} is a negative space the size of <punct>
\newcommand{\nspace}[1]{%
  \settowidth{\punctwidth}{#1}%
  \hspace*{-\the\punctwidth}%
}
% \npunct{<punct>} treats <punct> as having no width,
% so that footnotes after it can stack on top
\newcommand{\npunct}[1]{#1%
  \nspace{#1}%
}
% \nsup{<sup>}{<punct>} shifts <punct> left by
% the width of <sup> as a superscript
% so that footnotes *before* it will stack on top
\newcommand{\nsup}[2]{%
  \nspace{$^{#1}$}%
  #2%
}

\setlength{\fboxsep}{2pt}
\setlength{\abovecaptionskip}{0.5\baselineskip}

\hypersetup{
  colorlinks=true,
  urlcolor=blue,
  citecolor=magenta
}
\urlstyle{tt}

\title{Bounded First-Class Universe Levels \titlebreak in Type Theory}
\titlerunning{Bounded First-Class Universe Levels}
\authorrunning{J. Chan, S. Weirich}
\Copyright{Jonathan Chan, Stephanie Weirich}
\ccsdesc{Theory of computation~Type theory}
\keywords{type theory, universes, universe polymorphism}
\hideLIPIcs

\author{ionchy}
  {University of Pennsylvania, Philadelphia, USA}
  {jcxz@seas.upenn.edu}
  {0000-0003-0830-3180}
  {}

\author{Stephanie Weirich}
  {University of Pennsylvania, Philadelphia, USA}
  {sweirich@seas.upenn.edu}
  {0000-0002-6756-9168}
  {}

\supplementdetails[subcategory={source code},
  swhid={swh:1:dir:} % see https://www.softwareheritage.org/
]{Software}{https://github.com/ionathanch/TT-model}

\inputott{rules}

\acknowledgements{hi \href{https://types.pl}{\texttt{types.pl}}!}

\begin{document}

\maketitle

\begin{abstract}
  abstract
\end{abstract}

\section{Introduction}

TODO: explain ``universe'', ``bounded'', ``first class'', ``level polymorphism''

First-class universe levels are known to be logically consistent.
In particular, Kov\'{a}cs~\citep{gen-univ} gives a semantic model for a type theory TTFL,
which features first-class levels and an ordering relation $<$ on them.
The model is given as categories with families (cwfs)~\citep{cwf},
mostly mechanized in Agda using induction--recursion,
and supports features such as bounded level polymorphism,
least upper bounds on levels, and induction on levels,
which subsumes the predicative universe features in Agda, Rocq, and Lean.

The syntax of TTFL is considered to be the initial model in the category of cwfs,
but a concrete syntax and typing rules are not given,
and proving initiality even for MLTT is a colossal task~\citep{initiality}.
Furthermore, while a syntax may satisfy semantic properties such as logical consistency,
it may not necessarily satisfy desirable syntactic properties.
For instance, Bezem, Coquand, Dybjer, and Escard\'o~\citep{univ-poly}
introduce a concrete type theory with higher-order universe level polymorphism and level constraints,
whose semantics can conceivably be viewed as that of TTFL without making levels first class.
However, as they note, their type theory fails to satisfy substitution properties
and therefore violates subject reduction.

In this work, we give an end-to-end account of universe levels in type theory,
mechanized entirely in Lean.
Our contributions are as follows:

\begin{itemize}
  \item We state a concrete syntax and typing rules for a dependent type theory with
    bounded, first-class universe levels.
    Our bounds differ from level constraints in previous work in that
    they are inherent to the type of a level,
    rather than a separate predicate on them.
  \item We prove the syntactic properties of subject reduction (\ie preservation),
    progress, and type safety.
  \item Using a syntactic logical relation, we prove logical consistency and canonicity.
    However, normalization remains an open problem.
\end{itemize}

The development consists of just under 1600 lines of Lean code,
which can be found in the supplementary materials at \repo{}.
The definitions, lemmas, and theorems in this paper
are hyperlinked to the corresponding Lean files.

\section{Overview}

To see where bounded first-class universe levels situates itself among existing work,
we compare it against three of the most common proof assistants with level polymorphism:
Rocq, Lean, and Agda.%
\footnote{\fstar's universe polymorphism works the same as Lean's.}
An initial simple application is the level-polymorphic identity function.

\begin{table}[H]
\begin{tabular}{rp{0.54\textwidth}}
  \textsf{Rocq} &
  \begin{minipage}[t]{0.54\textwidth}
  \begin{minted}{coq}
Definition id@{u} (A : Type@{u}) (a : A) := a.
  \end{minted}
  \end{minipage}
  \\
  \midrule
  \textsf{Lean} &
  \begin{minipage}[t]{0.54\textwidth}
  \begin{minted}{lean}
def id.{u} (A : Type u) (a : A) : A := a
  \end{minted}
  \end{minipage}
  \\
  \midrule
  \textsf{Agda} &
  \begin{minipage}[t]{0.54\textwidth}
  \begin{minted}{agda}
id : ∀ (ℓ : Level) (A : Set ℓ) → A → A
id ℓ A a = a
  \end{minted}
  \end{minipage}
  \\
  \midrule
  \lang & $\kw{id} : [[:concrete: Πk: Level< o. ΠA: Type k. A → A]] \coloneq [[:concrete: λk. λA. λa. a]]$
\end{tabular}
\end{table}

In Rocq and Lean, a definition can be level polymorphic
by declaring a level variable \texttt{u}.
Here, levels are in a syntactic category independent of terms,
and only top-level definitions can be level polymorphic;
lambda functions cannot otherwise be assigned level-polymorphic types.
In Agda, levels are terms, and level polymorphism is universal quantification over a level type.
The concrete levels in this level type are \texttt{0}, \texttt{1}, \dots,
and universes in these levels live in a limit universe \mintinline{agda}{Setω}.
In our system, assuming we also have levels $[[0]], [[1]], \dots, [[o]]$,
we explicitly say which levels are quantified over by specifying the bound.

The expressive power of higher-order level quantification
afforded by its first-classness as compared to mere prenex quantification
becomes evident when we consider the universe in which the types of identity functions live.

\begin{table}[H]
\begin{tabular}{rp{0.7\textwidth}}
  \textsf{Rocq} &
  \begin{minipage}[t]{0.7\textwidth}
  \begin{minted}{coq}
Definition Id@{u v | u < v} : Type@{v} := ∀ (A : Type@{u}), A → A.
  \end{minted}
  \end{minipage}
  \\
  \midrule
  \textsf{Lean} &
  \begin{minipage}[t]{0.7\textwidth}
  \begin{minted}{lean}
def Id.{u} : Type (u + 1) := ∀ (A : Type u), A → A
  \end{minted}
  \end{minipage}
  \\
  \midrule
  \textsf{Agda} &
  \begin{minipage}[t]{0.7\textwidth}
  \begin{minted}{agda}
Id : Setω
Id = ∀ (ℓ : Level) (A : Set ℓ) → A → A
  \end{minted}
  \end{minipage}
  \\
  \midrule
  \lang & $\kw{Id} : [[Type o]] \coloneq [[:concrete: Πk: Level< o. ΠA: Type k. A → A]]$
\end{tabular}
\end{table}

Universe levels being second-class in Rocq and Lean means we cannot talk about level polymorphism itself;
the best we can do is assign a universe to the type of an identity function at a \emph{particular} level.
Because Rocq has cumulativity, a type that lives in a smaller universe also lives in a larger one,
so to type an identity function type over types at level \texttt{u},
it suffices to assign it a universe at an arbitrary larger level \texttt{v}
by declaring an inequality constraint between the two.
In Lean, which does not have cumulativity,
we instead assign it the precise successor level.
Meanwhile, in Agda, we are able to consider the type of level polymorphism itself.
Because the universe in which the return type could be at any level within \mintinline{agda}{ω},
the overall universe must be \mintinline{agda}{Setω},
and the same principle applies to our system.

Although Agda has optional and rudimentary support for cumulativity,
idiomatic code typically does not use this feature,
instead opting for precise levels using a successor operator \mintinline{agda}{suc}
and a maximum operator \mintinline{agda}{_⊔_} on two levels,
and similarly in Lean.
Without cumulativity, we need to take the maximum of two levels
when working with a type composed of types in different universes.
With cumulativity, we instead specify an upper bound.
A type constructor for the type of constant functions demonstrates this use case.

\begin{table}[H]
\begin{tabular}{rp{0.86\textwidth}}
  \textsf{Rocq} &
  \begin{minipage}[t]{0.86\textwidth}
  \begin{minted}{coq}
Definition Const@{u v w | u < w, v < w} (A : Type@{u}) (B : Type@{v}) : Type@{w} :=
  A → B → A
  \end{minted}
  \end{minipage}
  \\
  \midrule
  \textsf{Lean} &
  \begin{minipage}[t]{0.86\textwidth}
  \begin{minted}{lean}
def Const.{u, v} (A : Type u) (B : Type v) : Type (max u v) := A → B → A
  \end{minted}
  \end{minipage}
  \\
  \midrule
  \textsf{Agda} &
  \begin{minipage}[t]{0.86\textwidth}
  \begin{minted}{agda}
Const : ∀ (ℓ₁ ℓ₂ : Level) → Set ℓ₁ → Set ℓ₂ → Set (ℓ₁ ⊔ ℓ₂)
Const ℓ₁ ℓ₂ A B = A → B → A
  \end{minted}
  \end{minipage}
  \\
  \midrule
  \lang &
  \begin{minipage}[t]{0.86\textwidth}
  $\kw{Const} : [[:concrete: Πl: Level< o. Πj: Level< l. Πk: Level< l. Type j → Type k → Type l]]$ \\
  \phantom{$\kw{Const}$} $\coloneq [[:concrete: λl. λj. λk. λA. λB. A → B → A]]$
  \end{minipage}
\end{tabular}
\end{table}

In Lean and Agda, the level of the output universe is the maximum of that of the two input universes.
In Rocq and our system, which has cumulativity,
we achieve the same effect by abstracting over a third universe that bounds the other two.
The novel feature of combining bounding and first-classness
is the ability to bound levels not just by constant levels,
but also by arbitrary level terms, as is the case for $[[j]], [[k]]$ bounded by $[[l]]$.
Our system therefore encompasses both the cumulativity of Rocq via bounding
and the uniformity of Agda by treating levels as ordinary terms.

TODO: talk about bounding vs constraints, higher-rank level quantification, functions returning levels

\begin{table}
\begin{tabular}{lllll}
  \toprule
  System & Levels & Polymorphism & Operators & Subsumption \\
  \midrule
  Rocq & anonymous & prenex & $<, \le, =$ & subtyping \\
  Lean, \fstar & $\omega$ & prenex & $\mathrm{max}, {} + i$ & none \\
  Agda & $\omega + \omega$ & first class & $\mathrm{max}, {} + 1$ & cumulativity (optional) \\
  this work & --- & first class & $<$ & cumulativity \\
  \bottomrule \\
\end{tabular}
\caption{Comparison of proof assistants and universe level features}
\label{tab:comparison}
\end{table}

We summarize our comparison of this work to existing proof assistants in \cref{tab:comparison}.
To be more accurate, Rocq has a subtyping system that is more expressive than cumulativity,
which we discuss as an extension in \cref{sec:subtyping}.

\section{A basic type theory with bounded first-class universe levels}

We consider with a Curry-style type theory \`a la Russell,
where terms have no type annotations,
and there is no separate typing judgement for well-formedness of types.
To keep the type theory minimal, it contains only dependent functions,
an empty type, predicative universes, and bounded universe levels.
By convention, we use $[[a]], [[b]], [[c]]$ for terms,
$[[A]], [[B]], [[C]]$ for types,
and $[[k]], [[l]]$ for level terms.
The syntax is presented in nominally in \cref{fig:syntax},
although the mechanization uses de Bruijn indexing.
We write single substitution of a variable $[[x]]$ in a term $[[b]]$ by another term $[[a]]$
as $[[b{x ↦ a}]]$.
We also use $[[A → B]]$ as sugar for nondependent functions
$[[Πx : A. B]]$ where $[[x]]$ does not occur in $[[B]]$.

\begin{figure}
\begin{align*}
  i, j & \Coloneqq \texttt{<external universe levels>} \\
  x, y, z & \Coloneqq \texttt{<term variables>} \\
  a, b, c, A, B, C, k, \ell & \Coloneqq [[x]] \mid [[i]]
    \mid [[Πx : A. B]] \mid [[λx. b]] \mid [[b a]]
    \mid [[⊥]] \mid [[abs b]]
    \mid [[Type k]] \mid [[Level< l]] \\
  [[G]], [[D]] & \Coloneqq [[•]] \mid [[G, x : A]]
\end{align*}
\caption{Syntax}
\label{fig:syntax}
\end{figure}

The type theory is parametrized over a cofinal woset of levels,
\ie a set of levels that are well founded, totally ordered,
and each have some strictly larger level;
these properties are required when modelling the type theory.
Instances of such sets include the naturals $0, 1, 2, \dots$,
as well as the naturals extended by one limit ordinal $\omega$
and its successors $\omega + 1, \omega + 2, \dots$.
We continue to use these concrete levels for our examples.
These metalevel levels are internalized directly in system as terms $[[i]]$.

\begin{figure}
\begin{mathpar}
  \inferrule[\ottdrulename{Nil}]{~}{[[⊢ •]]}
  \and
  \inferrule[\ottdrulename{Cons}]
    {[[⊢ G]] \and
     [[G ⊢ A : Type k]]}
    %------------------%
    {[[⊢ G, x : A]]}
  \and
  \inferrule[\ottdrulename{Var}]
    {[[⊢ G]] \and
     [[x : A ∈ G]]}
    %-------------%
    {[[G ⊢ x : A]]}
  \and
  \inferrule[\ottdrulename{Pi}]
    {[[G ⊢ A : Type k]] \and
     [[G, x : A ⊢ B : Type k]]}
    %--------------------------%
    {[[G ⊢ Πx : A. B : Type k]]}
  \and
  \inferrule[\ottdrulename{Lam}]
    {[[G ⊢ Πx : A. B : Type k]] \and
     [[G, x : A ⊢ b : B]]}
    %-------------------------%
    {[[G ⊢ λx. b : Πx : A. B]]}
  \and
  \inferrule[\ottdrulename{App}]
    {[[G ⊢ b : Πx : A. B]] \and
     [[G ⊢ a : A]]}
    %----------------------%
    {[[G ⊢ b a : B{x ↦ a}]]}
  \and
  \inferrule[\ottdrulename{Mty}]
    {[[G ⊢ Type k : Type l]]}
    %-----------------------%
    {[[G ⊢ ⊥ : Type k]]}
  \and
  \inferrule[\ottdrulename{Abs}]
    {[[G ⊢ A : Type k]] \and
     [[G ⊢ b : ⊥]]}
    %-----------------%
    {[[G ⊢ abs b : A]]}
  \and
  \inferrule[\ottdrulename{Conv}]
    {[[G ⊢ a : A]] \and
     [[G ⊢ B : Type k]] \and
     [[A = B]]}
    %------------------%
    {[[G ⊢ a : B]]}
\end{mathpar}
%
\begin{mathpar}
  \inferrule[\ottdrulename{E-Beta}]{~}{[[(λx. b) a = b{x ↦ a}]]} \and
  \inferrule[\ottdrulename{E-Refl}]{~}{[[a = a]]} \and
  \inferrule[\ottdrulename{E-Sym}]{[[a = b]]}{[[b = a]]} \and
  \inferrule[\ottdrulename{E-Trans}]{[[a = b]] \and [[b = c]]}{[[a = c]]} \and
  \cdots
\end{mathpar}

\caption{Typing and selected equality rules (no universes or levels)}
\label{fig:typing:basic}
\end{figure}

We begin first with the basic rules that don't concern universes or levels in \cref{fig:typing:basic},
consisting of a context well-formedness judgement \fbox{$[[⊢ G]]$},
a typing judgement \fbox{$[[G ⊢ a : A]]$},
and an untyped definitional equality \fbox{$[[a = b]]$}.
\Rref{Lam} explicitly includes well-typedness of a function's type as a premise
rather than merely well-typedness of the domain type $[[A]]$
to guarantee that it lives at the same universe level as the codomain type $[[B]]$,
which we need to prove our fundamental theorem.
The remaining rules are otherwise as expected.
We use $\beta$-conversion as our definitional equality,
and omit the usual congruence rules.

\begin{figure}
\begin{mathpar}
  \inferrule[\ottdrulename{Univ}]
    {[[G ⊢ k : Level< l]]}
    %-----------------------%
    {[[G ⊢ Type k : Type l]]}
  \and
  \inferrule[\ottdrulename{Level<}]
    {[[G ⊢ Type k1 : Type l1]] \and
     [[G ⊢ k0 : Level< l0]]}
    %---------------------------%
    {[[G ⊢ Level< k0 : Type k1]]}
  \and
  \inferrule[\ottdrulename{Lvl}]
    {[[⊢ G]] \and
     [[i < j]]}
    %--------------------%
    {[[G ⊢ i : Level< j]]}
  \and
  \inferrule[\ottdrulename{Trans}]
    {[[G ⊢ k1 : Level< k2]] \and
     [[G ⊢ k2 : Level< k3]]}
    %----------------------%
    {[[G ⊢ k1 : Level< k3]]}
  \and
  \inferrule[\ottdrulename{Cumul}]
    {[[G ⊢ A : Type k]] \and
     [[G ⊢ k : Level< l]]}
    %--------------------%
    {[[G ⊢ A : Type l]]}
\end{mathpar}
\caption{Typing rules (universes and levels)}
\label{fig:typing:univ}
\end{figure}

The rules relating to universes and levels are given in \cref{fig:typing:univ}.
By \rref{Lvl}, we can view the type constructor $[[Level< _]]$
as the internalization of the order on levels.
As the level type is combined with level bounding,
it is impossible to declare a level variable strictly less than itself.
The level type itself can be typed at any universe by \rref{Level<}
regardless of what the bounding level is.
For example, we can construct a derivation for $[[• ⊢ Level< 2 : Type 0]]$
solely knowing that $[[• ⊢ 2 : Level< 3]]$ and $[[• ⊢ Type 0 : Type 1]]$.

\Rref{Trans} internalizes transitivity of the order on levels,
which is now required since levels are terms in general and not only concrete levels.
For example, we can construct a derivation for $[[x : Level< o, y : Level< x ⊢ x : Level< o]]$,
where the levels $[[x]], [[y]]$ are variables.

\Rref{Cumul} is a cumulativity rule that permits lifting a type
from one universe to a higher universe.
This rule is weaker than a full subtyping rule that accounts for
contravariance in the domain and covariance in the codomain of function types.
Therefore, for instance, $[[f : Type 2 → Type 0 ⊢ f : Type 1 → Type 1]]$ does \emph{not} hold.
Nonetheless, cumulativity allows us to instead type the $\eta$-expansion
$[[f : Type 2 → Type 0 ⊢ λx. f x : Type 1 → Type 1]]$.

Finally, \rref{Univ} asserts that a universe at level $[[k]]$
lives in the universe at level $[[l]]$ when $[[k]]$ is strictly bounded by $[[l]]$.
Allowing universes with general level terms and not just concrete levels
to be well typed is what permits typing level-polymorphic types.
For example, we can derive a typing judgement for
the following level-polymorphic identity function type:
$$[[• ⊢ Πx : Level< o. Πy : Type x. y → y : Type o]]$$
$[[Level< o]]$ can be assigned an arbitrary type by \rref{Level},
$[[Type x]]$ has type $[[Type o]]$ by \rref{Univ} and \rref{Var},
and $[[y]]$ can be assigned type $[[Type o]]$ transitively
via \rref{Trans,Var}.
Then the entire term has type $[[Type o]]$ by repeated application of \rref{Pi}.

\section{Metatheory}

The key properties of the type theory that we prove are
type safety and logical consistency.
Type safety is proven using standard syntactic methods
to show progress and preservation (\ie subject reduction).
Consistency follows from the fundamental soundness theorem
for a logical relation on closed types
where the empty type is interpreted as the empty set of terms.
The fundamental theorem also gives canonicity results for other types:
closed terms of the universe reduce to types,
and closed terms of level types reduce to concrete levels.

All results are mechanized in Lean.
While the mechanization uses de Bruijn indexing and simultaneous substitutions,
we omit the details of manipulating these substitutions,
continuing to state theorems in nominal form
to focus on the ideas rather than the minutiae.

\subsection{Type safety}

Our type safety theorem is stated in terms of a call-by-name evaluation strategy,
which we define shortly.
In essence, closed, well-typed terms evaluate (if they terminate) to values,
which are type formers and constructors,
defined as follows.
$$[[v]] \Coloneqq [[i]] \mid [[Πx: A. B]] \mid [[λx. b]] \mid [[⊥]] \mid [[Type k]] \mid [[Level< l]]$$

\subsubsection{Reduction and conversion}

\begin{figure}
\begin{mathpar}
  \inferrule[\ottdrulename{P-Beta}]
    {[[b ⇒ b']] \and
     [[a ⇒ a']]}
    %--------------------------%
    {[[(λx. b) a ⇒ b'{x ↦ a'}]]}
  \and
  \inferrule[\ottdrulename{P-Var}]{~}{[[x ⇒ x]]}
  \quad
  \inferrule[\ottdrulename{P-Mty}]{~}{[[⊥ ⇒ ⊥]]}
  \and
  \inferrule[\ottdrulename{P-Pi}]
    {[[A ⇒ A']] \and
     [[B ⇒ B']]}
    %-------------------------%
    {[[Πx: A. B ⇒ Πx: A'. B']]}
  \and
  \inferrule[\ottdrulename{P-Lam}]
    {[[b ⇒ b']]}
    %------------------%
    {[[λx. b ⇒ λx. b']]}
  \and
  \inferrule[\ottdrulename{P-App}]
    {[[b ⇒ b']] \and
     [[a ⇒ a']]}
    %---------------%
    {[[b a ⇒ b' a']]}
  \and
  \inferrule[\ottdrulename{P-Abs}]
    {[[b ⇒ b']]}
    %------------------%
    {[[abs b ⇒ abs b']]}
  \and
  \inferrule[\ottdrulename{P-Univ}]
    {[[k ⇒ k']]}
    %--------------------%
    {[[Type k ⇒ Type k']]}
  \and
  \inferrule[\ottdrulename{P-Level<}]
    {[[l ⇒ l']]}
    %------------------------%
    {[[Level< l ⇒ Level< l']]}
  \quad
  \inferrule[\ottdrulename{P-Lvl}]{~}{[[i ⇒ i]]}
\end{mathpar}
\caption{Parallel reduction rules}
\label{fig:par}
\end{figure}

Rather than working directly with $\beta$-reduction,
we use parallel reduction \fbox{$[[a ⇒ b]]$},
defined in \cref{fig:par},
and its reflexive, transitive closure \fbox{$[[a ⇒* b]]$},
into which call-by-name evaluation embeds.
We begin with simple lemmas about parallel reduction, stated without proof.

\begin{lemma}[Substitution (p.r.)] \label{lem:pars:subst}
  If $[[a ⇒* a']]$ and $[[b ⇒* b']]$,
  then $[[b{x ↦ a} ⇒* b'{x ↦ a'}]]$.
\end{lemma}

\begin{lemma}[Congruence (p.r.)] \label{lem:pars:cong}
  Parallel reduction is congruent,
  \eg if $[[A ⇒* A']]$ and $[[B ⇒* B']]$,
  then $[[Πx: A. B ⇒ Πx: A'. B']]$,
  and so on for all terms.
\end{lemma}

\begin{lemma}[Construction (p.r.)] \label{lem:pars:cons}
  Analogous constructors of parallel reduction hold
  for its reflexive, transitive closure,
  \eg if $[[b ⇒* b']]$ and $[[a ⇒* a']]$,
  then $[[(λx. b) a ⇒* b'{x ↦ a'}]]$.
\end{lemma}

\begin{lemma}[Inversion (p.r.)] \label{lem:pars:inv}
  If $[[v ⇒* c]]$, then $[[c]]$ is also a value of the same syntactic shape
  such that the reduction is congruent,
  \eg if $[[λx. b ⇒* c]]$, then $[[c]]$ is syntactically equal to $[[λx. b']]$
  for some $[[b']]$ such that $[[b ⇒* b']]$.
\end{lemma}

Similarly, rather than working directly with definitional equality,
we use conversion \fbox{$[[a ⇔ b]]$},
which is defined in terms of parallel reduction.

\begin{definition}[Conversion]
  $[[a ⇔ b]]$ iff there exists a $[[c]]$ such that
  $[[a ⇒* c]]$ and $[[b ⇒* c]]$
\end{definition}

\begin{figure}
\begin{align*}
  \begin{aligned}
    [[(Πx: A. B) ^ T]] &\triangleq [[Πx: A ^ T. B ^ T]] \\
    [[(λx. b) ^ T]] &\triangleq [[λx. b ^ T]] \\
    [[(abs b) ^ T]] &\triangleq [[abs b ^ T]]
  \end{aligned}
  &
  \begin{aligned}
    [[(Type k) ^ T]] &\triangleq [[Type k ^ T]] \\
    [[(Level< l) ^ T]] &\triangleq [[Level< l ^ T]] \\
    [[a ^ T]] &\triangleq a ~ \textit{otherwise}
  \end{aligned}
  &
  \begin{aligned}
    [[(b a) ^ T]] &\triangleq
    \begin{cases}
      [[b' ^ T {x ↦ a ^ T}]] &\textit{if } [[b]] \textit{ is } [[λx. b']] \\
      [[b ^ T a ^ T]] &\textit{otherwise}
    \end{cases} \\
    &
  \end{aligned}
\end{align*}
\caption{Complete development}
\label{fig:taka}
\end{figure}

Proving that conversion is transitive requires proving confluence for parallel reduction,
which we prove using the notion of complete development by Takahashi~\citep{takahashi}.
Complete development \fbox{$[[a ^ T]]$} is defined in \cref{fig:taka},
and is used to join parallel reductions and prove the diamond property.

\begin{lemma}[Completion (p.r.)] \label{lem:par:compl}
  If $[[a ⇒ b]]$, then $[[b ⇒ a ^ T]]$.
\end{lemma}

\begin{corollary}[Diamond (p.r.)] \label{lem:par:diamond}
  If $[[a ⇒ b]]$ and $[[a ⇒ c]]$,
  then there exists some $[[d]]$ such that $[[b ⇒ d]]$ and $[[c ⇒ d]]$.
  In particular, $[[d]]$ is $[[a ^ T]]$,
  with the reductions given by \nameref{lem:par:compl}.
\end{corollary}

\begin{theorem}[Confluence (p.r.)] \label{lem:par:confl}
  If $[[a ⇒* b]]$ and $[[a ⇒* c]]$,
  then there exists some $[[d]]$ such that $[[b ⇒* d]]$ and $[[c ⇒* d]]$.
\end{theorem}

\begin{corollary}[Properties of conversion] \label{lem:conv}
  Conversion is reflexive, symmetric, transitive, substitutive, and congruent.
  Transitivity requires \nameref{lem:par:confl};
  the remaining properties are straightforward
  from the corresponding properties of parallel reduction.
\end{corollary}

Inversion on parallel reduction gives syntactic consistency and injectivity of conversion.

\begin{lemma}[Syntactic consistency] \label{lem:par:consistency}
  If $[[v1]]$ and $[[v2]]$ have different syntactic shapes,
  then $[[v1 ⇔ v2]]$ is impossible.
\end{lemma}

\begin{lemma}[Injectivity (conv.)] ~
  \begin{enumerate}[topsep=0pt]
    \item If $[[Πx: A1. B1 ⇔ Πx: A2. B2]]$, then $[[A1 ⇔ A2]]$ and $[[B1 ⇔ B2]]$.
    \item If $[[Type k1 ⇔ Type k2]]$, then $[[k1 ⇔ k2]]$.
  \end{enumerate}
\end{lemma}

Finally, definitional equality is equivalent to conversion,
which allows us to use them interchangeably later on.
The right-to-left direction is proven using induction on parallel reduction,
while the left-to-right direction is proven by induction on definitional equality,
using the various properties of conversion.

\begin{theorem} \label{lem:eq-conv}
  $[[a = b]]$ iff $[[a ⇔ b]]$.
\end{theorem}

\subsubsection{Subject reduction}

To prove subject reduction,
we begin first with some simple inversion properties on typing derivations,
proven directly by induction.

\begin{lemma}[Context well-formedness] \label{lem:wt:wf}
  If $[[G ⊢ a : A]]$, then $[[⊢ G]]$.  
\end{lemma}

\begin{lemma}[Context well-typedness]
  If $[[⊢ G]]$ and $[[x : A ∈ G]]$,
  then there exists some $[[k]]$ such that $[[G ⊢ A : Type k]]$.
\end{lemma}

\begin{lemma}[Regularity] \label{lem:wt:reg}
  If $[[G ⊢ a : A]]$, then there exists some $[[k]]$ such that
  $[[G ⊢ A : Type k]]$.
\end{lemma}

Next, we require weakening, substitution, and replacement lemmas.
They follow from stronger forms of these lemmas involving simultaneous renaming and substitution,
whose details we omit.

\begin{lemma}[Weakening (w.t.)] \label{lem:wt:weak}
  If $[[⊢ G]]$, $[[G ⊢ B : Type k]]$, and $[[G ⊢ a : A]]$,
  then $[[G, x : B ⊢ a : A]]$, where $[[x]]$ is not in $[[a]]$ or $[[A]]$.
\end{lemma}

\begin{proof}
  A renaming lemma is proven by induction on the typing derivation of $[[a]]$,
  showing that applying well-scoped renamings preserves typing.
  Weakening is then the special case of a single renaming by $[[x]]$ to avoid capture.
\end{proof}

\begin{lemma}[Substitution (w.t.)] \label{lem:wt:subst}
  If $[[G ⊢ b : B]]$ and $[[G, x : B ⊢ a : A]]$,
  then $[[G ⊢ a{x ↦ b} : A{x ↦ b}]]$.
\end{lemma}

\begin{proof}
  A morphing lemma is proven by induction on the typing derivation of $[[a]]$,
  showing that applying well-typed substitutions preserves typing.
  Substitution is then the special case of a single substitution of $[[x]]$.
\end{proof}

\begin{lemma}[Replacement (w.t.)] \label{lem:wt:replace}
  If $[[A = B]]$, $[[G ⊢ B : Type k]]$, and $[[G, x : A ⊢ c : C]]$,
  then $[[G, x : B ⊢ c : C]]$.
\end{lemma}

\begin{proof}
  The morphing lemma allows us to change the context from one to the other
  as long as there is a well-typed substitution between them.
  We can show that the identity substitution is such a substitution
  by proving $[[G, x : B ⊢ x : A]]$.
  This follows from \rref{Conv},
  \nameref{lem:wt:wf} for well-typedness of $[[A]]$,
  and \nameref{lem:wt:weak} to weaken it.
\end{proof}

Finally, the proof of subject reduction requires many of the above lemmas.

\begin{theorem}[Subject reduction] \label{lem:preservation}
  If $[[a ⇒ b]]$ and $[[G ⊢ a : A]]$, then $[[G ⊢ b : A]]$.
\end{theorem}

\begin{proof}
  By induction on the typing derivation of $[[a]]$.
  The most complex case is when the reduction is \rref*{P-Beta},
  requiring \cref{lem:conv}, \nameref{lem:wt:subst},
  \nameref{lem:wt:replace}, and \nameref{lem:wt:reg}.
  Even so, the proof is standard,
  and the cases for the universe and level rules in \cref{fig:typing:univ}
  follow directly from the induction hypotheses.
\end{proof}

\subsubsection{Progress}

\begin{figure}
\begin{mathpar}
  \inferrule[\ottdrulename{N-Beta}]{~}
    {[[(λx. b) a ⇝ b{x ↦ a}]]}
  \and
  \inferrule[\ottdrulename{N-App}]
    {[[b ⇝ b']]}
    %--------------%
    {[[b a ⇝ b' a]]}
  \and
  \inferrule[\ottdrulename{N-Abs}]
    {[[b ⇝ b']]}
    %------------------%
    {[[abs b ⇝ abs b']]}
\end{mathpar}
\caption{Call by name reduction}
\label{fig:cbn}
\end{figure}

Our notion of evaluation in the progress and type safety theorems
is the reflexive, transitive closure \fbox{$[[a ⇝* b]]$}
of call-by-name (cbn) reduction \fbox{$[[a ⇝ b]]$},
defined in \cref{fig:cbn},
which reduces $\beta$-redexes and head positions.
A single step of cbn reduction embeds into
a single step of parallel reduction by induction.

\begin{lemma}
  If $[[a ⇝ b]]$ then $[[a ⇒ b]]$.
\end{lemma}

Because cbn reduces under eliminators for functions and proofs of falsehood,
we need to know what values of function and empty types are.
The following lemmas are proven by induction,
using inversion lemmas on typing derivations as needed.

\begin{lemma}[Canonical function values] \label{lem:canon:fun}
  If $[[G ⊢ v : Πx: A. B]]$,
  then $[[v]]$ has the syntactic shape $[[λx. b]]$ for some $[[b]]$.
\end{lemma}

\begin{lemma}[Canonical false values] \label{lem:canon:false}
  There is no $[[v]]$ such that $[[G ⊢ v : ⊥]]$.
\end{lemma}

Finally, we prove progress, which with subject reduction we show type safety:
closed, well-typed terms either reduce to a value, or must continue reducing.

\begin{theorem}[Progress] \label{lem:progress}
  If $[[• ⊢ a : A]]$, then either $[[a]]$ is a value,
  or $[[a ⇝ b]]$ for some $[[b]]$.
\end{theorem}

\begin{proof}
  By induction on the typing derivation of $[[a]]$,
  using \cref{lem:canon:fun,lem:canon:false}
  in the cases for \rref{App,Abs}, respectively.
\end{proof}

\begin{theorem}[Type safety]
  If $[[• ⊢ a : A]]$ and $[[a ⇝* b]]$,
  then either $[[b]]$ is a value,
  or $[[b ⇝ c]]$ for some $[[c]]$.
\end{theorem}

\begin{proof}
  By induction on the reduction $[[a ⇝* c]]$.
  The reflexive case holds by \nameref{lem:progress}.
  In the transitive case where $[[a ⇝ b]]$ and $[[b ⇝* c]]$,
  the goal holds by the induction hypothesis on the latter reduction,
  using \nameref{lem:preservation} for well typedness of $[[b]]$
  from the former.
\end{proof}

\subsection{Consistency and canonicity}

To prove consistency and canonicity,
we use a logical relation to semantically interpret closed types as sets of closed terms;
these sets are backward closed under reduction,
so if a term reduces to something in the set, then it is also in the set.
The empty type is interpreted as the empty set,
universes as sets of terms that reduce to types,
and level types as sets of terms that reduce to concrete levels.
Consistency and canonicity then follow from the fundamental soundness theorem,
which states that if a term $[[a]]$ has type $[[A]]$,
then $[[a]]$ is in the interpretation of $[[A]]$.
The structure of the logical relation and the soundness proof
is adapted from the mechanization by Liu~\citep{lr-pearl},
and we cover important details here,
especially as they pertain to universes and levels.

\subsubsection{Logical relation for closed types}

The logical relation is written as \fbox{$[[⟦ A ⟧ i ↘ P]]$},
where $[[A]]$ is the type, $[[P]]$ is the set of terms,
and $[[i]]$ is the universe level of the type.
A set of terms $[[P]]$ is mechanized as a predicate on terms,
though we to write $[[a ∈ P]]$ in lieu of $[[P]]([[a]])$
to say that $[[a]]$ is in the set,
and we use set-builder notation in lieu of explicit abstractions.
When proving properties of the logical relation,
we require no other axioms than function extensionality and propositional extensionality;
for transparency, we mark the lemmas in which they are used with $\dagger$.

Because universes are interpreted as sets of types
which themselves have interpretations at a lower universe level,
to ensure that the interpretation is well defined,
the mechanization implements it as an inductive definition
parametrized by interpretations at lower levels,
then ties the knot by well-founded induction on levels.
For clarity and concision, we ignore these mechanization details
and present the logical relation in \cref{fig:lr:closed}
without worrying about well-foundedness.

\begin{figure}
\begin{mathpar}
  \inferrule[\ottdrulename{I-Mty}]{~}
    {[[⟦ ⊥ ⟧ i ↘ ∅]]}
  \and
  \inferrule[\ottdrulename{I-Univ}]
    {[[j < i]]}
    %---------------------------------------%
  {[[⟦ Type j ⟧ i ↘ {z | ∃ P. ⟦ z ⟧ j ↘ P}]]}
  \and
  \inferrule[\ottdrulename{I-Level<}]{~}
    {[[⟦ Level< j1 ⟧ i ↘ {z | ∃ j2. z ⇒* j2 ∧ j1 < j2}]]}
  \and
  \inferrule[\ottdrulename{I-Step}]
    {[[A ⇒ B]] \and
     [[⟦ B ⟧ i ↘ P]]}
     %--------------%
    {[[⟦ A ⟧ i ↘ P]]}
  \and
  \inferrule[\ottdrulename{I-Pi}]
    {[[⟦ A ⟧ i ↘ P1]] \and
     [[∀ y. y ∈ P1 → ∃ P2. R(y, P2)]] \\\\
     [[∀ y. ∀ P2. R(y, P2) → ⟦ B{x ↦ y} ⟧ i ↘ P2]]}
    %-------------------------------------------------------------------%
    {[[⟦ Πx : A. B ⟧ i ↘ {f | ∀ y. ∀ P2. R(y, P2) → y ∈ P1 → f y ∈ P2}]]}
\end{mathpar}
\caption{Logical relation for closed types}
\label{fig:lr:closed}
\end{figure}

Let us get the easier cases out of the way.
\Rref{I-Step} backward closes the interpretation under reduction of the type,
so a type has an interpretation if it reduces to a type with an interpretation.
We show shortly that forward closure under reduction of the type also holds,
as well as backward closure under reduction of the \emph{terms} in the interpretations.%
\footnote{We will not require forward closure.}
The interpretation of the empty type as the empty set is given by \rref{I-Mty}.

Because we consider the interpretation of closed types only,
and we explicitly have a constructor for backward closure,
the only other constructors we need are those for normal, closed types.
In particular, we need only consider $[[Type j]]$ and $[[Level< j1]]$
with concrete levels rather than arbitrary level terms.
The interpretation of $[[Level< j1]]$ given by \rref{I-Level<}
is the set of level terms strictly less than $[[j1]]$;
more precisely, it is the set of terms that reduce to such concrete levels.
The interpretation of $[[Type j]]$ given by \rref{I-Univ}
is the set of types that have an interpretation.

The intuition behind \rref{I-Pi} for function types is that a function $[[f]]$
is in its interpretation if for every argument $[[y]]$ in the interpretation of the domain,
the application $[[f y]]$ is in the interpretation of the codomain.
Because we are dealing with dependent types,
the interpretation of the codomain varies with the argument,
so we need to ensure first that the interpretation exists
for \emph{every} argument in the interpretation of the domain,
and that $[[f y]]$ is in the \emph{particular} interpretation of the codomain.
It then sounds like we would want \rref{I-Pi'} below.
%
\begin{mathpar}
  \inferrule[\ottdrulename{I-Pi'}]
    {[[⟦ A ⟧ i ↘ P1]] \and
     [[∀ y. y ∈ P1 → ∃ P2. ⟦ B{x ↦ y} ⟧ i ↘ P2]]}
    %--------------------------------------------------------------------------------%
    {[[⟦ Πx : A. B ⟧ i ↘ {f | ∀ y. ∀ P2. (⟦ B{x ↦ y} ⟧ i ↘ P2) → y ∈ P1 → f y ∈ P2}]]}
\end{mathpar}

The problem is that the interpretation is not strictly positive in the conclusion,
so \rref*{I-Pi'} as a constructor is not well defined.
\Rref{I-Pi} therefore uses an auxiliary relation $[[R]]$
that relates the argument $[[y]]$ to the interpretation of the codomain $[[B{x ↦ y}]]$.
\Rref{I-Pi'} then holds by instantiating $[[R(y, P2)]]$ with $[[⟦B{x ↦ y}⟧ i ↘ P2]]$ in \rref{I-Pi}.
This is the same trick used by Liu~\citep{lr-pearl},
whose origins are documented by Anand and Rahli~\citep{mech-nuprl}.

We require of the logical relation inversion properties for each constructor,
along with properties that hold \apriori for syntactic typing:
conversion and cumulativity.
A key intermediate lemma is functionality,
\ie that the interpretation of a type is deterministic.
We begin with closures over reductions to prove conversion.

\begin{lemma}[Forward and backward closure (l.r.)] \label{lem:lr:pars} ~
  \begin{enumerate}
    \item If $[[⟦A⟧ i ↘ P]]$ and either $[[A ⇒ B]]$ or $[[A ⇒* B]]$,
      then $[[⟦B⟧ i ↘ P]]$.
    \item If $[[⟦B⟧ i ↘ P]]$ and either $[[A ⇒ B]]$ or $[[A ⇒* B]]$,
      then $[[⟦A⟧ i ↘ P]]$.
  \end{enumerate}
\end{lemma}

\begin{proof} ~
  \begin{enumerate}
    \item For $[[A ⇒ B]]$, by induction on the logical relation,
      using \nameref{lem:par:diamond} in the \rref*{I-Step} case.
      \nameref{lem:pars:subst} is needed in the \rref*{I-Pi} case
      to manipulate the substitution in the function codomain.
      For $[[A ⇒* B]]$, by induction on this reduction.
    \item For $[[A ⇒* B]]$, by induction on this reduction,
      using \rref{I-Step}. \qedhere
  \end{enumerate}
\end{proof}

\begin{corollary}[Conversion (l.r.)]
  If $[[⟦A⟧ i ↘ P]]$ and $[[A ⇔ B]]$,
  then $[[⟦B⟧ i ↘ P]]$,
  using forward and backward closure.
\end{corollary}

The final closure lemma we need is backward closure of the terms in the interpretations.
When proving the fundamental theorem,
we encounter situations where our goal requires inclusion of a reduced term in an interpretation,
while induction hypotheses only piece together inclusion of the term before reduction.

\begin{lemma}[Backward closure] \label{lem:lr:back}
  If $[[⟦A⟧ i ↘ P]]$ and $[[a ⇒* b]]$,
  then $[[b ∈ P]]$ implies $[[a ∈ P]]$.
\end{lemma}

\begin{proof}
  By induction on the logical relation.
  In the \rref*{I-Univ} case, where $[[a]]$ and $[[b]]$ are types,
  we use backward closure from \cref{lem:lr:pars}.
\end{proof}

Cumulativity holds directly by induction on the logical relation.

\begin{lemma}[Cumulativity (l.r.)] \label{lem:lr:cumul}
  Suppose $[[i < j]]$. If $[[⟦A⟧ i ↘ P]]$, then $[[⟦A⟧ j ↘ P]]$.
\end{lemma}

The inversion principles for each constructor of the logical relation
hold by induction, using properties of parallel reduction as needed.
However, it is the inversion principle for \rref{I-Pi'} that we want.
The issue lies in the set of terms of the interpretation:
if we do not yet know that the sets are unique,
then inversion on \rref{I-PI} gives \emph{some} interpretation $[[P1]]$ of the codomain,
but we do not know whether it is \emph{the} interpretation that is required.
We solve this by proving functionality.

\begin{lemma}[Fixed-level functionality (l.r.)]$\!\!{\dagger}$ \label{lem:lr:fixed-func}
  If $[[⟦A⟧ i ↘ P]]$ and $[[⟦A⟧ i ↘ Q]]$, then $[[P]] = [[Q]]$.
\end{lemma}

\begin{proof}
  By induction on the first logical relation,
  then generally inversion on the second,
  except for the \rref*{I-Step} case,
  which holds directly by the induction hypothesis
  and forward closure on the second logical relation.
  The complex case is \rref*{I-Pi},
  where we must prove the two sets of terms equal,
  knowing by the induction hypotheses
  that the interpretations of the domain and codomain yield equal sets.
  Because sets are encoded as predicates,
  we need to use predicate extensionality,
  \ie function extensionality followed by propositional extensionality.
  It then suffices to show that membership in one set implies membership in the other,
  which holds using the induction hypotheses.
\end{proof}

Functionality holds even with different universe levels,
the idea being that the interpretation of a type is independent
of the level at which it lives.

\begin{lemma}[Functionality (l.r.)] \label{lem:lr:func}
  If $[[⟦A⟧ i ↘ P]]$ and $[[⟦A⟧ j ↘ Q]]$, then $[[P]] = [[Q]]$.
\end{lemma}

\begin{proof}
  By totality of the order on levels,
  either $[[i]]$ and $[[j]]$ are equal,
  or one is strictly larger than the other.
  In the latter case,
  we use \nameref{lem:lr:cumul} to lift the logical relation at the lower level to the higher level.
  Then the sets are equal by \nameref{lem:lr:fixed-func}.
\end{proof}

Finally, we are able to prove the inversion property for \rref{I-Pi'},
which we explicitly state below.

\begin{lemma}[Inversion on function types (l.r.)]$\!\!{\dagger}$ \label{lem:lr:inv-pi}
  If $[[⟦Πx: A. B⟧ i ↘ P]]$,
  then there exists a $[[P1]]$ such that:
  \begin{enumerate}
    \item \label{lem:inv-pi:goal:A} $[[⟦ A ⟧ i ↘ P1]]$;
    \item \label{lem:inv-pi:goal:B} $[[∀ y. y ∈ P1 → ∃ P2. ⟦ B{x ↦ y} ⟧ i ↘ P2]]$; and
    \item \label{lem:inv-pi:goal:P} $[[P]] = [[{f | ∀ y. ∀ P2. (⟦ B{x ↦ y} ⟧ i ↘ P2) → y ∈ P1 → f y ∈ P2}]]$.
  \end{enumerate}
\end{lemma}

\begin{proof}
  By inversion on the logical relation,
  which gives $[[P1]]$ and $[[R]]$ such that the following hold:
  \begin{enumerate}[start=4]
    \item \label{lem:inv-pi:hyp:A} $[[⟦ A ⟧ i ↘ P1]]$;
    \item \label{lem:inv-pi:hyp:R} $[[∀ y. y ∈ P1 → ∃ P2. R(y, P2)]]$;
    \item \label{lem:inv-pi:hyp:B} $[[∀ y. ∀ P2. R(y, P2) → ⟦ B{x ↦ y} ⟧ i ↘ P2]]$; and
    \item \label{lem:inv-pi:hyp:P} $[[P]] = [[{f | ∀ y. ∀ P2. R(y, P2) → y ∈ P1 → f y ∈ P2}]]$.
  \end{enumerate}
  \ref{lem:inv-pi:goal:A} holds directly by \ref{lem:inv-pi:hyp:A},
  and \ref{lem:inv-pi:goal:B} holds by combining \ref{lem:inv-pi:hyp:R} and \ref{lem:inv-pi:hyp:B}.
  To show that the sets in \ref{lem:inv-pi:goal:P} and \ref{lem:inv-pi:hyp:P} are equal,
  we again use predicate extensionality.
  \begin{itemize}
    \item \textit{\ref{lem:inv-pi:goal:P} implies \ref{lem:inv-pi:hyp:P}.}
      Supposing $[[y]]$ and $[[P2]]$,
      we have three hypotheses $[[(⟦ B{x ↦ y} ⟧ i ↘ P2) → y ∈ P1 → f y ∈ P2]]$,
      $[[R(y, P2)]]$, and $[[y ∈ P1]]$.
      From \ref{lem:inv-pi:hyp:B} on the second hypothesis,
      we have $[[⟦ B{x ↦ y} ⟧ i ↘ P2]]$,
      so we can apply the first hypothesis to get $[[f y ∈ P2]]$.
    \item \textit{\ref{lem:inv-pi:hyp:P} implies \ref{lem:inv-pi:goal:P}.}
      Supposing $[[y]]$ and $[[P2]]$,
      we have three hypotheses $[[R(y, P2) → y ∈ P1 → f y ∈ P2]]$,
      $[[⟦ B{x ↦ y} ⟧ i ↘ P2]]$, and $[[y ∈ P1]]$.
      Instantiating the first hypothesis using \ref{lem:inv-pi:hyp:R},
      we know there exists a $[[P2']]$ such that $[[f y ∈ P2']]$.
      From \ref{lem:inv-pi:hyp:B}, we also know that $[[⟦ B{x ↦ y} ⟧ i ↘ P2']]$.
      Then by \nameref{lem:lr:func}, we have $[[P2]] = [[P2']]$, so $[[f y ∈ P2]]$.
      \qedhere
  \end{itemize}
\end{proof}

It is worthwhile to also explicitly state the inversion principle
asserting that types that have interpretations are indeed one of the four types,
proven by induction on the logical relation.

\begin{lemma}[Inversion (l.r.)] \label{lem:lr:inv}
  If $[[⟦C⟧ i ↘ P]]$, then one of the following holds:
  \begin{itemize}
    \item There exist $[[A]]$ and $[[B]]$ such that $[[C ⇒* Πx: A. B]]$;
    \item There exists $[[i]]$ such that $[[C ⇒* Type i]]$;
    \item There exists $[[i]]$ such that $[[C ⇒* Level< i]]$; or
    \item $[[C ⇒* ⊥]]$.
  \end{itemize}
\end{lemma}

\subsubsection{Fundamental soundness theorem}

Although the logical relation relates closed types to sets of closed terms,
the fundamental theorem is proven over syntactic typing of open terms,
so we need a notion of semantic typing that handles closing over the terms
in a given typing context with a simultaneous substitution.
Semantic typing is then elementhood of a term in the interpretation of its type
for any substitution that closes them both.

At this point, referring to simultaneous substitutions is inevitable.
We denote them as $[[s]]$, and write $[[s, x ↦ a]]$
for its extension by a single substitution of $[[x]]$ by $[[a]]$.
In the mechanization, semantic well-typedness of a substitution \fbox{$[[s ⊧ G]]$}
is defined similarly to semantic typing \fbox{$[[G ⊢ a : A]]$},
but the admissible rules defined in \cref{fig:sem:subst} are more convenient.

\begin{definition}
  A substitution $[[s]]$ is semantically well typed
  with respect to a context $[[G]]$ iff for every $[[x : A ∈ G]]$,
  there exist $[[i]], [[P]]$ such that
  $[[⟦A{s}⟧ i ↘ P]]$ and $[[x{s} ∈ P]]$.
\end{definition}

\begin{figure}
\begin{mathpar}
  \mprset{fraction={\cdot\cdots\cdot}}
  \inferrule[\ottdrulename{I-Nil}]{~}{[[s ⊧ •]]}
  \and
  \inferrule[\ottdrulename{I-Cons}]
    {[[s ⊧ G]] \and
     [[⟦A{s}⟧ i ↘ P]] \and
     [[a ∈ P]]}
    %-----------------------%
    {[[s, x ↦ a ⊧ G, x : A]]}
\end{mathpar}
\caption{Semantically well-typed substitutions}
\label{fig:sem:subst}
\end{figure}

\begin{definition}[Semantic typing]
  A term $[[a]]$ is semantically well typed with type $[[A]]$ under context $[[G]]$,
  written $[[G ⊧ a : A]]$, iff for every $[[s]]$ such that $[[s ⊧ G]]$,
  there exist $[[i]], [[P]]$ such that
  $[[⟦A{s}⟧ i ↘ P]]$ and $[[a{s} ∈ P]]$.
\end{definition}

The fundamental soundness theorem of syntactic typing with respect to semantic typing
states that syntactic typing implies semantic typing.
The cases corresponding to the rules in \cref{fig:typing:basic} are routine
by construction and inversion of \rref{I-Pi,I-Mty}~\citep{lr-pearl},
so we do not cover them all here.
Instead, we detail only the \rref*{I-Lam} case to highlight
where some of the above lemmas are used,
followed by the cases for the rules in \cref{fig:typing:univ}
that are unique to our system.
For concision, we skip steps involving massaging substitutions into the right shape.

\begin{theorem}[Soundness] \label{thm:soundness}
  If $[[G ⊢ a : A]]$, then $[[G ⊧ a : A]]$.
\end{theorem}

\begin{proof}
  By induction on the typing derivation.
  In each case, we suppose that $[[s ⊧ G]]$.
  \begin{itemize}
    \item \textit{\Rref{Lam}.}
      The premises are $[[G ⊢ Πx: A. B : Type k]]$ and $[[G, x : A ⊢ b : B]]$,
      concluding with $[[G ⊢ λx. b : Πx: A. B]]$.
      By the induction hypothesis on the first premise,
      the function type is in the interpretation of a universe,
      so it also has an interpretation by inversion,
      allowing us to apply \nameref{lem:lr:inv-pi}.
      This gives $[[⟦A{s}⟧ i ↘ P1]]$, $[[⟦ B{s, x ↦ a} ⟧ i ↘ P2]]$, and $[[a ∈ P1]]$,
      where the goal is now to show that $[[(λx. b) a ∈ P2]]$.
      By \rref{I-Cons} and the induction hypothesis on the second premise,
      we have $[[⟦B{s, x ↦ a}⟧ i' ↘ P2']]$ and $[[b{x ↦ a} ∈ P2']]$ for some $[[i']], [[P2']]$.
      By \nameref{lem:lr:func}, we have that $[[P2]] = [[P2']]$.
      Finally, by \nameref{lem:lr:back} on \rref{P-Beta} and $[[b{x ↦ a} ∈ P2]]$,
      we obtain $[[(λx. b) a ∈ P2]]$.
    \item \textit{\Rref{Univ}.}
      The premise is $[[G ⊢ k : Level< l]]$,
      concluding with $[[G ⊢ Type k : Type l]]$.
      By the induction hypothesis on the premise,
      followed by inversion on the interpretation of level types,
      we know that $[[k{s} ⇒* i1]]$ and $[[l{s} ⇒* i2]]$ such that $[[i1 < i2]]$.
      By cofinality, we also know that there must exist a $[[j]]$ such that $[[i2 < j]]$.
      The goal is now to show that $[[⟦Type (l{s})⟧ j ↘ {z | ∃ P. ⟦ z ⟧ i2 ↘ P}]]$
      and $[[⟦Type (k{s})⟧ i2 ↘ {z | ∃ P. ⟦ z ⟧ i1 ↘ P}]]$.
      These are both constructed using \rref{I-Univ} and \cref{lem:lr:pars}.
    \item \textit{\Rref{Level<}.}
      The premises are $[[G ⊢ Type k1 : Type l1]]$ and $[[G ⊢ k0 : Level< l0]]$,
      concluding with $[[G ⊢ Level< k0 : Type k1]]$.
      By the induction hypothesis on the first premises,
      $[[Type (k1{s})]]$ is in the interpretation of a universe.
      By inversion, we know that it too has an interpretation as a universe,
      so it remains to show that $[[⟦Level< (k0{s})⟧ j ↘ P]]$ for some $[[P]]$,
      where $[[k1{s} ⇒* j]]$.
      By the induction on the second premise,
      followed by inversion on the interpretation of level types,
      we know that $[[k0{s} ⇒* i]]$ for some $[[i]]$.
      Then the goal is constructed using \rref{I-Level<} and \cref{lem:lr:pars}.
    \item \textit{\Rref{Lvl}.} Straightforward by construction using \rref{I-Level<}.
    \item \textit{\Rref{Trans}.}
      The premises are $[[G ⊢ k1 : Level< k2]]$ and $[[G ⊢ k2 : Level< k3]]$,
      concluding with $[[G ⊢ k1 : Level< k3]]$.
      By the induction hypotheses on the two premises,
      followed by inversion on the interpretation of level types,
      we know that $[[k1{s} ⇒* i1]]$, $[[k2{s} ⇒* i2]]$, $[[k2{s} ⇒* i2']]$, and $[[k3{s} ⇒* i3]]$
      such that $[[i1 < i2]]$ and $[[i2' < i3]]$.
      By \nameref{lem:par:confl} and \nameref{lem:par:consistency},
      it must be that $[[i2]] = [[i2']]$.
      From the second inversion, we already know that $[[Level< (k3{s})]]$ has an interpretation,
      so it remains to show that $[[k1{s} ⇒* i1]]$ and $[[k3{s} ⇒* i3]]$ such that $[[i1 < i3]]$,
      which holds by transitivity.
    \item \textit{\Rref{Cumul}.}
      The premises are $[[G ⊢ A : Type k]]$ and $[[G ⊢ k : Level< l]]$,
      concluding with $[[G ⊢ A : Type l]]$.
      By induction on the first premise,
      followed by inversion on the interpretation of universes,
      we know that $[[k{s} ⇒* i]]$ and $[[⟦A{s}⟧ i ↘ P]]$ for some $[[P]]$.
      By induction on the second premise,
      followed by inversion on the interpretation of levels,
      we know that $[[k{s} ⇒* i']]$ and $[[l{s} ⇒* j]]$ such that $[[i' < j]]$.
      By \nameref{lem:par:confl} and \nameref{lem:par:consistency},
      it must be that $[[i]] = [[i']]$.
      Similar to the \rref{Univ} case,
      we can show that $[[Type (l{s})]]$ has an interpretation as a universe.
      The final goal is then to show that $[[⟦A{s}⟧ j ↘ P]]$,
      which holds by \nameref{lem:lr:cumul} on $[[i < j]]$.
      \qedhere
  \end{itemize}
\end{proof}

Consistency and canonicity results then follow from the fundamental theorem as corollaries.

\begin{corollary}[Consistency]
  There is no $[[b]]$ such that $[[• ⊢ b : ⊥]]$ holds.
  If there were, by \nameref{thm:soundness},
  we would have $[[• ⊧ b : ⊥]]$.
  Instantiating with the identity substitution,
  then inverting on the interpretation of $[[⊥]]$,
  we would have that $[[b ∈ ∅]]$, which is a contradiction.
\end{corollary}

\begin{corollary}[Canonicity of types] \label{lem:canon:univ}
  If $[[• ⊢ C : Type k]]$,
  then either $[[C ⇒* Πx: A. B]]$, $[[C ⇒* Type i]]$, $[[C ⇒* Level< i]]$, or $[[C ⇒* ⊥]]$.
  By \nameref{thm:soundness},
  instantiating with the identity substitution,
  we have some $[[j]], [[Q]]$ such that $[[⟦Type k⟧ j ↘ Q]]$ and $[[C ∈ Q]]$.
  By inversion on the former,
  we then have some $[[i]], [[P]]$ such that $[[k ⇒* i]]$ and $[[⟦C⟧ i ↘ P]]$.
  Then the goal holds by \nameref{lem:lr:inv}.
\end{corollary}

\begin{corollary}[Canonicity of levels]
  If $[[• ⊢ k : Level< l]]$,
  then $[[k ⇒* i]]$ for some concrete level $[[i]]$.
  By \nameref{thm:soundness},
  instantiating with the identity substitution,
  we have some $[[j]], [[P]]$ such that $[[⟦Level< l⟧ j ↘ P]]$ and $[[k ∈ P]]$.
  By inversion on the former,
  we then have that $[[l ⇒* i2]]$ and $[[k ⇒* i1]]$ such that $[[i1 < i2]]$.
\end{corollary}

\subsection{Counterexample to normalization}

Our type theory is not normalizing.
While directly declaring an ill-founded level $[[x : Level< x]]$ is impossible,
we can construct such a level in an inconsistent context.
Then it becomes possible to type the universe at this level as its own type.
\Cref{fig:type-in-type} explicitly constructs the key part of the typing derivation
for $[[Type (abs x)]] : [[Type (abs x)]]$ where $[[x]] : [[⊥]]$.
With an instance of type-in-type,
it is possible to construct a nonnormalizing lambda term,
for instance via Hurkens' paradox~\citep{hurkens}.

\begin{figure}
\begin{mathpar}
  \inferrule*[Left=\rref*{Univ}]{
  \inferrule*[Left=\rref*{Abs}]{
    \inferrule*[Left=\rref*{Level<}]{
      \inferrule*[Left=\rref*{Univ}]{
      \inferrule*[Left=\rref*{Lvl}]{0 < 1}{[[x : ⊥ ⊢ 0 : Level< 1]]}}
      {[[x : ⊥ ⊢ Type 0 : Type 1]]}
      \and
      \inferrule*[Right=\rref*{Abs}]{
      \inferrule*[]{\dots}{[[x : ⊥ ⊢ Level< 0 : Type 0]]}
      \and
      \inferrule*[Right=\rref*{Var}]{[[x : ⊥ ∈ x : ⊥]]}{[[x : ⊥ ⊢ x : ⊥]]}}
      {[[x : ⊥ ⊢ abs x : Level< 0]]}}
      {[[x : ⊥ ⊢ Level< (abs x) : Type 0]]}
    \and
    \inferrule*[Right=\rref*{Var}]{[[x : ⊥ ∈ x : ⊥]]}{[[x : ⊥ ⊢ x : ⊥]]}}
    {[[x : ⊥ ⊢ abs x : Level< (abs x)]]}}
  {[[x : ⊥ ⊢ Type (abs x) : Type (abs x)]]}
\end{mathpar}
\caption{Type-in-type in an inconsistent context}
\label{fig:type-in-type}
\end{figure}

The ability to assign different types to the term $[[abs x]]$ is key to constructing this derivation.
If the eliminator for falsehood required a type annotation,
and more importantly if type annotations required comparison in definitional equality,
we could only construct a derivation for
$[[Type (abs' (Level< (abs' (Level< 0) x)) x)]] : [[Type (abs' (Level< 0) x)]]$,
which can no longer be used as type-in-type.
For similar reasons, we cannot use $[[x]] : [[:concrete: ΠA: Type i. A]]$
to construct the ill-founded level, as the type arguments will be incomparable.

It is unclear whether adding a type annotation to $[[abs _]]$
(or removing the empty type entirely) would resolve the issue of nonnormalization,
as we have not found a counterexample without eliminating falsehoods.
Conversely, it is also unclear how to define extend the logical relation to prove normalization
by generalizing it to open types and terms.
The issue lies in the interpretation of a universe at a level that is a neutral term.

Consider for example $[[x : Level< o, y : Level< x ⊢ Type y : Type x]]$.
What types live in $[[Type y]]$?
If $[[x]]$ is $[[0]]$, then there is no possible $[[y]]$,
and $[[Type y]]$ has no interpretation as a universe;
otherwise, it \emph{could} have an interpretation.
Without assuming that $[[x]]$ reduces to a canonical, concrete level,
we have no way of interpreting $[[Type y]]$.
We cannot simply say that universes with neutral levels only contain neutral terms, either,
as $[[Type x]]$ is such a universe that clearly contains the normal term $[[Type y]]$.

\section{Conclusion and future work}

\subsection{Extensions}

Our type theory is intentionally minimal to focus only on the core necessities
of first-class levels and to keep the proof development small and uncluttered.
Some reasonable extensions include the remaining missing types from MLTT,
\ie dependent pairs, sums, naturals, propositional equality, and W types,
or general inductive types as in CIC~\citep{pcuic}.
However, these features and their difficulties are orthogonal from universes and levels.
Here, we instead look at extensions that augment how universes and levels behave,
some of which are validated by our current semantics,
and others which present additional challenges.

\subsubsection{Level operators}

The only features that we do not have but Agda does are a zeroth level,
a level successor operator, and a level maximum operator.
To justify them semantically,
we would impose the first two as additional existence conditions on the metalevel levels;
the third follows from the total ordering, which lets us pick the larger of two levels.
Their typing rules are straightforward, given below.
%
\begin{mathpar}
  \inferrule[\ottdrulename{Zero}]
    {[[G ⊢ k : Level< l]]}
    %------------------------%
    {[[G ⊢ 0 : Level< (↑ k)]]}
  \and
  \inferrule[\ottdrulename{Succ}]
    {[[G ⊢ k : Level< l]]}
    %--------------------------%
    {[[G ⊢ ↑ k : Level< (↑ l)]]}
  \and
  \inferrule[\ottdrulename{Max}]
    {[[G ⊢ k1 : Level< l1]] \and
     [[G ⊢ k2 : Level< l2]]}
    %----------------------------------%
    {[[G ⊢ k1 ⊔ k2 : Level< (l1 ⊔ l2)]]}
\end{mathpar}

What complicates matters are the additional definitional equalities that need to be added
to ensure that the maximum operator is idempotent, associative, commutative,
distributive with respect to successors,
and that $[[0]]$ is its identity element.
While these properties hold automatically at the metalevel for concrete levels,
they do not for arbitrary level expressions,
\eg $[[0 ⊔ ↑ (x ⊔ ↑ x) = ↑ ↑ x]]$.
Our notions of reduction then need to pick a direction for each equality
to reduce levels to some chosen canonical form.
We believe the mechanization to be doable, but tedious and uninteresting.

\subsubsection{Level and universe eliminators}

Levels and universes can at the moment only be constructed, but not eliminated.
Even so, well-founded induction on levels holds at the metalevel,
which we need to define our logical relation in the first place.
We can internalize it by syntactically introducing an eliminator,
which states that a predicate $[[B]]$ holds on arbitrary levels
if we can show that it holds for a given level
when we know it holds for all smaller levels.
However, it is unclear whether this eliminator would be useful.
%
\begin{mathpar}
  \inferrule[ElimLvl]
    {[[G, z : Level< k ⊢ B : Type l]] \\\\
     [[G ⊢ b : Πx: Level< k. (Πy: Level< x. B{z ↦ y}) → B{z ↦ x}]]}
    %-------------------------------%
    {[[G ⊢ wf b : Πz : Level< k. B]]}
  \and
  \inferrule[E-ElimLvl]{~}{[[wf b k = b k (λy. wf b y)]]}
\end{mathpar}

For universes, the simplest form of an eliminator is a typecase operator,
matching on a type as a function type, the empty type, a universe, or a level type.
Such an operator is justified by \nameref{lem:canon:univ}.
TODO: Expound on the utility of typecase,
and write down an explicit typing rule if possible.

\subsubsection{Subtyping} \label{sec:subtyping}

Because levels are now terms,
subtyping necessarily involves typing to compare two levels.
In particular, a universe at a smaller level is a subtype of a universe at a larger level,
while a level type bounded by a smaller level is a subtype of a level bounded by a larger level.
The former is already expressed by \rref{Cumul}, the latter by \rref{Trans}.
In this sense, the sole benefit of subtyping is being able to subtype function types,
making function domains contravariant and codomains covariant with respect to subtyping.
A number of these subtyping rules are given below,
along with an updated \rref{Conv'} rule.
%
\begin{mathpar}
  \inferrule[\ottdrulename{S-Univ}]
    {[[G ⊢ k : Level< l]]}
    %-----------------------%
    {[[G ⊢ Type k ≤ Type l]]}
  \and
  \inferrule[\ottdrulename{S-Level<}]
    {[[G ⊢ k : Level< l]]}
    %---------------------------%
    {[[G ⊢ Level< k ≤ Level< l]]}
  \and
  \inferrule[\ottdrulename{S-Pi}]
    {[[G ⊢ A2 ≤ A1]] \and
     [[G, x: A1 ⊢ B1 ≤ B2]]}
    %-------------------------------%
    {[[G ⊢ Πx: A1. B1 ≤ Πx: A2. B2]]}
  \and
  \inferrule[\ottdrulename{S-Trans}]
    {[[G ⊢ A ≤ B]] \and
     [[G ⊢ B ≤ C]]}
    %-------------%
    {[[G ⊢ A ≤ C]]}
  \and
  \inferrule[\ottdrulename{S-Conv}]
    {[[A = B]]}
    %-------------%
    {[[G ⊢ A ≤ B]]}
  \and
  \inferrule[\ottdrulename{Conv'}]
    {[[G ⊢ a : A]] \and
     [[G ⊢ B : Type k]] \and
     [[G ⊢ A ≤ B]]}
    %-------------%
    {[[G ⊢ a : B]]}
\end{mathpar}

Although all of this subtyping behaviour holds semantically in our current model,
proving logical consistency is not so easy.
The simplicity of our logical relation relies on
the independence of definitional equality from typing,
along with its equivalence to conversion.
By introducing a subtyping judgement that depends on typing,
which in turn depends on subtyping, to prove consistency,
the logical relation would have to be extended to include a semantic notion of equality,
similar to the reducibility judgements used by Abel, \"Ohman, and Vezzosi~\citep{dec-conv}.

\bibliographystyle{plainurl}
\bibliography{main.bib}

\end{document}
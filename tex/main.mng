\documentclass[a4paper,UKenglish,cleveref,autoref,thm-restate]{lipics-v2021}

% \pdfoutput=1
% \hideLIPIcs

\usepackage[supertabular]{ottalt}
\let\newlist\relax
\let\renewlist\relax
\usepackage{enumitem,xspace,doi}
\usepackage{mathpartir,mathtools,stmaryrd}
\usepackage[flushmargin,multiple,para]{footmisc} % para spacing is weird and ugly

\newcommand{\citep}[1]{\cite{#1}}
\newcommand{\citet}[1]{\cite{#1}}
\newcommand{\publicrepo}{\url{https://github.com/ionathanch/TT-model}}
\newcommand{\lang}{\textsf{TT}\@\xspace}
\newcommand{\titlebreak}{\texorpdfstring{\\}{}}
\newcommand{\ie}{\textit{i.e.}\@\xspace}
\newcommand{\eg}{\textit{e.g.}\@\xspace}
\newcommand{\etal}{\textit{et al.}\@\xspace}
\newcommand{\vs}{\textit{vs.}\@\xspace}
\newcommand{\welltyped}{well-\hspace{0pt}typed\@\xspace}
\newcommand{\wellfounded}{well-\hspace{0pt}founded\@\xspace}
\newcommand{\wellfoundedness}{well-\hspace{0pt}foundedness\@\xspace}
\newcommand{\wellformedness}{well-\hspace{0pt}formedness\@\xspace}
\newcommand{\welldefinedness}{well-\hspace{0pt}definedness\@\xspace}
\newcommand{\crude}{crude-\hspace{0pt}but-\hspace{0pt}effective\@\xspace}

\newcommand{\footfile}[1]{%
  \raggedright
  \href{\publicrepo{}/tree/main/TT-model/#1}{\texttt{#1}}
}
\newcommand{\footfilethm}[2]{%
  \raggedright
  \href{\publicrepo{}/tree/main/TT-model/#1}{\texttt{#1}}\texttt{:#2}
}

\setlength{\fboxsep}{1.5pt}

\newlength{\punctwidth}
% \nspace{<punct>} is a negative space the size of <punct>
\newcommand{\nspace}[1]{%
  \settowidth{\punctwidth}{#1}%
  \hspace*{-\the\punctwidth}%
}
% \npunct{<punct>} treats <punct> as having no width,
% so that footnotes after it can stack on top
\newcommand{\npunct}[1]{#1%
  \nspace{#1}%
}
% \nsup{<sup>}{<punct>} shifts <punct> left by
% the width of <sup> as a superscript
% so that footnotes *before* it will stack on top
\newcommand{\nsup}[2]{%
  \nspace{$^{#1}$}%
  #2%
}

\setlength{\fboxsep}{2pt}
\setlength{\abovecaptionskip}{0.5\baselineskip}

\hypersetup{
  colorlinks=true,
  urlcolor=blue,
  citecolor=magenta
}
\urlstyle{tt}

\title{Bounded First-Class Universe Levels \titlebreak in Type Theory}
\titlerunning{Bounded First-Class Universe Levels}
\authorrunning{J. Chan, S. Weirich}
\Copyright{Jonathan Chan, Stephanie Weirich}
\ccsdesc{Theory of computation~Type theory}
\keywords{type theory, universes, universe polymorphism}
\hideLIPIcs

\author{Jonathan Chan}
  {University of Pennsylvania, Philadelphia, USA}
  {jcxz@seas.upenn.edu}
  {0000-0003-0830-3180}
  {}

\author{Stephanie Weirich}
  {University of Pennsylvania, Philadelphia, USA}
  {sweirich@seas.upenn.edu}
  {0000-0002-6756-9168}
  {}

\supplementdetails[subcategory={source code},
  swhid={swh:1:dir:} % see https://www.softwareheritage.org/
]{Software}{https://github.com/ionathanch/TT-model}

\inputott{rules}

\acknowledgements{hi \href{https://types.pl}{\texttt{types.pl}}!}

\begin{document}

\maketitle

\begin{abstract}
  abstract
\end{abstract}

\section{Introduction}

\subsection{Comparison to other work}

\section{A basic type theory with bounded first-class universe levels}

We consider with a Curry-style type theory \`a la Russell,
where terms have no type annotations,
and there is no separate typing judgement for well-formedness of types.
To keep the type theory minimal, it contains only dependent functions,
an empty type, predicative universes, and bounded universe levels.
By convention, we use $[[a]], [[b]], [[c]]$ for terms,
$[[A]], [[B]], [[C]]$ for types,
and $[[k]], [[l]]$ for level terms.
The syntax is presented in nominally in \cref{fig:syntax},
although the mechanization uses de Bruijn indexing.
We write single substitution of a variable $[[x]]$ in a term $[[b]]$ by another term $[[a]]$
as $[[b{x ↦ a}]]$.
We also use $[[A → B]]$ as sugar for nondependent functions
$[[Πx : A. B]]$ where $[[x]]$ does not occur in $[[B]]$.

\begin{figure}
\begin{align*}
  i, j & \Coloneqq \texttt{<external universe levels>} \\
  x, y, z & \Coloneqq \texttt{<term variables>} \\
  a, b, c, A, B, C, k, \ell & \Coloneqq [[x]] \mid [[i]]
    \mid [[Πx : A. B]] \mid [[λx. b]] \mid [[b a]]
    \mid [[⊥]] \mid [[abs b]]
    \mid [[Type k]] \mid [[Level< l]] \\
  [[G]], [[D]] & \Coloneqq [[•]] \mid [[G, x : A]]
\end{align*}
\caption{Syntax}
\label{fig:syntax}
\end{figure}

The type theory is parametrized over a cofinal woset of levels,
\ie a set of levels that are well founded, totally ordered,
and each have some strictly larger level;
these properties are required when modelling the type theory.
Instances of such sets include the naturals $0, 1, 2, \dots$,
as well as the naturals extended by one limit ordinal $\omega$
and its successors $\omega + 1, \omega + 2, \dots$.
We continue to use these concrete levels for our examples.
These metalevel levels are internalized directly in system as terms $[[i]]$.

\begin{figure}
\begin{mathpar}
  \fbox{$[[⊢ G]]$} \qquad \fbox{$[[G ⊢ a : A]]$} \qquad \fbox{$[[a = b]]$} \hfill \\
  \inferrule[\ottdrulename{Nil}]{~}{[[⊢ •]]}
  \and
  \inferrule[\ottdrulename{Cons}]
    {[[⊢ G]] \and
     [[G ⊢ A : Type k]]}
    %------------------%
    {[[⊢ G, x : A]]}
  \and
  \inferrule[\ottdrulename{Var}]
    {[[⊢ G]] \and
     [[x : A ∈ G]]}
    %-------------%
    {[[G ⊢ x : A]]}
  \and
  \inferrule[\ottdrulename{Pi}]
    {[[G ⊢ A : Type k]] \and
     [[G, x : A ⊢ B : Type k]]}
    %--------------------------%
    {[[G ⊢ Πx : A. B : Type k]]}
  \and
  \inferrule[\ottdrulename{Lam}]
    {[[G ⊢ Πx : A. B : Type k]] \and
     [[G, x : A ⊢ b : B]]}
    %-------------------------%
    {[[G ⊢ λx. b : Πx : A. B]]}
  \and
  \inferrule[\ottdrulename{App}]
    {[[G ⊢ b : Πx : A. B]] \and
     [[G ⊢ a : A]]}
    %----------------------%
    {[[G ⊢ b a : B{x ↦ a}]]}
  \and
  \inferrule[\ottdrulename{Mty}]
    {[[G ⊢ Type k : Type l]]}
    %-----------------------%
    {[[G ⊢ ⊥ : Type k]]}
  \and
  \inferrule[\ottdrulename{Abs}]
    {[[G ⊢ A : Type k]] \and
     [[G ⊢ b : ⊥]]}
    %-----------------%
    {[[G ⊢ abs b : A]]}
  \and
  \inferrule[\ottdrulename{Conv}]
    {[[G ⊢ a : A]] \and
     [[G ⊢ B : Type k]] \and
     [[A = B]]}
    %------------------%
    {[[G ⊢ a : B]]}
\end{mathpar}
%
\begin{mathpar}
  \inferrule[\ottdrulename{E-Beta}]{~}{[[(λx. b) a = b{x ↦ a}]]} \and
  \inferrule[\ottdrulename{E-Refl}]{~}{[[a = a]]} \and
  \inferrule[\ottdrulename{E-Sym}]{[[a = b]]}{[[b = a]]} \and
  \inferrule[\ottdrulename{E-Trans}]{[[a = b]] \and [[b = c]]}{[[a = c]]} \and
  \cdots
\end{mathpar}

\caption{Typing and selected equality rules (no universes or levels)}
\label{fig:typing:basic}
\end{figure}

We begin first with the basic rules that don't concern universes or levels in \cref{fig:typing:basic},
consisting of a context well-formedness judgement $[[⊢ G]]$,
a typing judgement $[[G ⊢ a : A]]$, and an untyped definitional equality $[[a = b]]$.
\Rref{Lam} explicitly includes well-typedness of a function's type as a premise
rather than merely well-typedness of the domain type $[[A]]$
to guarantee that it lives at the same universe level as the codomain type $[[B]]$,
which we need to prove our fundamental theorem.
The remaining rules are otherwise as expected.
We use $\beta$-conversion as our definitional equality,
and omit the usual congruence rules.

\begin{figure}
\begin{mathpar}
  \inferrule[\ottdrulename{Univ}]
    {[[G ⊢ k : Level< l]]}
    %-----------------------%
    {[[G ⊢ Type k : Type l]]}
  \and
  \inferrule[\ottdrulename{Level<}]
    {[[G ⊢ Type k1 : Type l1]] \and
     [[G ⊢ k0 : Level< l0]]}
    %---------------------------%
    {[[G ⊢ Level< k0 : Type k1]]}
  \and
  \inferrule[\ottdrulename{Lvl}]
    {[[⊢ G]] \and
     [[i < j]]}
    %--------------------%
    {[[G ⊢ i : Level< j]]}
  \and
  \inferrule[\ottdrulename{Trans}]
    {[[G ⊢ k1 : Level< k2]] \and
     [[G ⊢ k2 : Level< k3]]}
    %----------------------%
    {[[G ⊢ k1 : Level< k3]]}
  \and
  \inferrule[\ottdrulename{Sub}]
    {[[G ⊢ A : Type k]] \and
     [[G ⊢ k : Level< l]]}
    %--------------------%
    {[[G ⊢ A : Type l]]}
\end{mathpar}
\caption{Typing rules (universes and levels)}
\label{fig:typing:univ}
\end{figure}

The rules relating to universes and levels are given in \cref{fig:typing:univ}.
By \rref{Lvl}, we can view the type constructor $[[Level< _]]$
as the internalization of the order on levels.
As the level type is combined with level bounding,
it is impossible to declare a level variable strictly less than itself.
The level type itself can be typed at any universe
regardless of what the bounding level is.
For example, we can construct a derivation for $[[• ⊢ Level< 2 : Type 0]]$
solely knowing that $[[• ⊢ 2 : Level< 3]]$ and $[[• ⊢ Type 0 : Type 1]]$.

\Rref{Trans} internalizes transitivity of the order on levels,
which is now required since levels are terms in general and not only concrete levels.
For example, we can construct a derivation for $[[x : Level< o, y : Level< x ⊢ x : Level< o]]$,
where the levels $[[x]], [[y]]$ are variables.

\Rref{Sub} is a subsumption rule that permits lifting a type
from one universe to a higher universe.
This rule is weaker than a full cumulativity rule that accounts for
contravariance in the domain and covariance in the codomain of function types.
Therefore, for instance, $[[f : Type 2 → Type 0 ⊢ f : Type 1 → Type 1]]$ does \emph{not} hold.
Nonetheless, subsumption allows us to instead type the $\eta$-expansion
$[[f : Type 2 → Type 0 ⊢ λx. f x : Type 1 → Type 1]]$.

Finally, \rref{Univ} asserts that a universe at level $[[k]]$
lives in the universe at level $[[l]]$ when $[[k]]$ is strictly bounded by $[[l]]$.
Allowing universes with general level terms and not just concrete levels
to be well typed is what permits typing level-polymorphic types.
For example, we can derive a typing judgement for
the following level-polymorphic identity function type:
$$[[• ⊢ Πx : Level< o. Πy : Type x. y → y : Type o]]$$
$[[Level< o]]$ can be assigned an arbitrary type by \rref{Level},
$[[Type x]]$ has type $[[Type o]]$ by \rref{Univ} and \rref{Var},
and $[[y]]$ can be assigned type $[[Type o]]$ transitively
via \rref{Trans,Var}.
Then the entire term has type $[[Type o]]$ by repeated application of \rref{Pi}.

\section{Metatheory}

The key properties of the type theory that we prove are
type safety and logical consistency.
Type safety is proven using standard syntactic methods
to show progress and preservation (\ie subject reduction).
Consistency follow from the fundamental soundness theorem
for a logical relation on closed types
where the empty type is interpreted as the empty set of terms.
The fundamental theorem also gives canonicity results for other types:
closed terms of the universe reduce to types,
and closed terms of level types reduce to concrete levels.

All of these results are mechanized in Lean.
While the mechanization uses de Bruijn indexing and simultaneous substitutions,
we omit the details of manipulating these substitutions,
continuing to state theorems in nominal form
to focus on the ideas rather than the minutiae.

\subsection{Type safety}

Our type safety theorem is stated in terms of a call-by-name evaluation strategy,
which we define shortly.
Closed terms evaluate (if they terminate) to values,
which are type formers and constructors,
defined as follows.
$$[[v]] \Coloneqq [[i]] \mid [[Πx: A. B]] \mid [[λx. b]] \mid [[⊥]] \mid [[Type k]] \mid [[Level< l]]$$

\subsubsection{Reduction and conversion}

\begin{figure}
\begin{mathpar}
  \inferrule[\ottdrulename{P-Beta}]
    {[[b ⇒ b']] \and
     [[a ⇒ a']]}
    {[[(λx. b) a ⇒ b'{x ↦ a'}]]}
  \and
  \inferrule[\ottdrulename{P-Var}]{~}{[[x ⇒ x]]}
  \quad
  \inferrule[\ottdrulename{P-Mty}]{~}{[[⊥ ⇒ ⊥]]}
  \and
  \inferrule[\ottdrulename{P-Pi}]
    {[[A ⇒ A']] \and
     [[B ⇒ B']]}
    {[[Πx: A. B ⇒ Πx: A'. B']]}
  \and
  \inferrule[\ottdrulename{P-Lam}]
    {[[b ⇒ b']]}
    {[[λx. b ⇒ λx. b']]}
  \and
  \inferrule[\ottdrulename{P-App}]
    {[[b ⇒ b']] \and
     [[a ⇒ a']]}
    {[[b a ⇒ b' a']]}
  \and
  \inferrule[\ottdrulename{P-Abs}]
    {[[b ⇒ b']]}
    {[[abs b ⇒ abs b']]}
  \and
  \inferrule[\ottdrulename{P-Univ}]
    {[[k ⇒ k']]}
    {[[Type k ⇒ Type k']]}
  \and
  \inferrule[\ottdrulename{P-Level<}]
    {[[l ⇒ l']]}
    {[[Level< l ⇒ Level< l']]}
  \quad
  \inferrule[\ottdrulename{P-Lvl}]{~}{[[i ⇒ i]]}
\end{mathpar}
\caption{Parallel reduction rules}
\label{fig:par}
\end{figure}

Rather than working directly with $\beta$-reduction,
we use parallel reduction $[[a ⇒ b]]$,
defined in \cref{fig:par},
and its reflexive, transitive closure $[[a ⇒* b]]$,
into which call-by-name evaluation embeds.
We begin with simple lemmas about parallel reduction, stated without proof.

\begin{lemma}[Substitution (p.r.)] \label{lem:pars:subst}
  If $[[a ⇒* a']]$ and $[[b ⇒* b']]$,
  then $[[b{x ↦ a} ⇒* b'{x ↦ a'}]]$.
\end{lemma}

\begin{lemma}[Congruence (p.r.)] \label{lem:pars:cong}
  Parallel reduction is congruent,
  \eg if $[[A ⇒* A']]$ and $[[B ⇒* B']]$,
  then $[[Πx: A. B ⇒ Πx: A'. B']]$,
  and so on for all terms.
\end{lemma}

\begin{lemma}[Construction (p.r.)] \label{lem:pars:cons}
  Analogous constructors of parallel reduction hold
  for its reflexive, transitive closure,
  \eg if $[[b ⇒* b']]$ and $[[a ⇒* a']]$,
  then $[[(λx. b) a ⇒* b'{x ↦ a'}]]$.
\end{lemma}

\begin{lemma}[Inversion (p.r.)] \label{lem:pars:inv}
  If $[[v ⇒* c]]$, then $[[c]]$ is also a value of the same syntactic shape
  such that the reduction is congruent,
  \eg if $[[λx. b ⇒* c]]$, then $[[c]]$ is syntactically equal to $[[λx. b']]$
  for some $[[b']]$ such that $[[b ⇒* b']]$.
\end{lemma}

Similarly, rather than working directly with definitional equality,
we use conversion $[[a ⇔ b]]$,
which is defined in terms of parallel reduction.

\begin{definition}[Conversion]
  $[[a ⇔ b]]$ iff there exists a $[[c]]$ such that
  $[[a ⇒* c]]$ and $[[b ⇒* c]]$
\end{definition}

\begin{figure}
\begin{align*}
  \begin{aligned}
    [[(Πx: A. B) ^ T]] &\triangleq [[Πx: A ^ T. B ^ T]] \\
    [[(λx. b) ^ T]] &\triangleq [[λx. b ^ T]] \\
    [[(abs b) ^ T]] &\triangleq [[abs b ^ T]]
  \end{aligned}
  &
  \begin{aligned}
    [[(Type k) ^ T]] &\triangleq [[Type k ^ T]] \\
    [[(Level< l) ^ T]] &\triangleq [[Level< l ^ T]] \\
    [[a ^ T]] &\triangleq a ~ \textit{otherwise}
  \end{aligned}
  &
  \begin{aligned}
    [[(b a) ^ T]] &\triangleq
    \begin{cases}
      [[b' ^ T {x ↦ a ^ T}]] &\textit{if } [[b]] \textit{ is } [[λx. b']] \\
      [[b ^ T a ^ T]] &\textit{otherwise}
    \end{cases} \\
    &
  \end{aligned}
\end{align*}
\caption{Definition of complete development}
\label{fig:taka}
\end{figure}

Proving that conversion is transitive requires proving confluence for parallel reduction,
which we prove using the notion of complete development by Takahashi~\citep{takahashi}.
Complete development $[[a ^ T]]$ is defined in \cref{fig:taka},
and is used to join parallel reductions and prove the diamond property.

\begin{lemma}[Completion (p.r.)] \label{lem:par:compl}
  If $[[a ⇒ b]]$, then $[[b ⇒ a ^ T]]$.
\end{lemma}

\begin{corollary}[Diamond (p.r.)]
  If $[[a ⇒ b]]$ and $[[a ⇒ c]]$,
  then there exists some $[[d]]$ such that $[[b ⇒ d]]$ and $[[c ⇒ d]]$.
  In particular, $[[d]]$ is $[[a ^ T]]$,
  with the reductions given by \nameref{lem:par:compl}.
\end{corollary}

\begin{theorem}[Confluence (p.r.)] \label{lem:par:confl}
  If $[[a ⇒* b]]$ and $[[a ⇒* c]]$,
  then there exists some $[[d]]$ such that $[[b ⇒* d]]$ and $[[c ⇒* d]]$.
\end{theorem}

\begin{corollary}[Properties of conversion]
  Conversion is reflexive, symmetric, transitive, substitutive, and congruent.
  Transitivity requires \nameref{lem:par:confl};
  the remaining properties are straightforward
  from the corresponding properties of parallel reduction.
\end{corollary}

Inversion on parallel reduction gives syntactic consistency and injectivity of conversion.

\begin{lemma}[Syntactic consistency]
  If $[[v1]]$ and $[[v2]]$ have different syntactic shapes,
  then $[[v1 ⇔ v2]]$ is impossible.
\end{lemma}

\begin{lemma}[Injectivity] ~
  \begin{enumerate}[topsep=0pt]
    \item If $[[Πx: A1. B1 ⇔ Πx: A2. B2]]$, then $[[A1 ⇔ A2]]$ and $[[B1 ⇔ B2]]$.
    \item If $[[Type k1 ⇔ Type k2]]$, then $[[k1 ⇔ k2]]$.
  \end{enumerate}
\end{lemma}

Finally, definitional equality is equivalent to conversion,
which allows us to use them interchangeably later on.
The right-to-left direction is proven using induction on parallel reduction,
while the left-to-right direction is proven by induction on definitional equality,
using the various properties of conversion.

\begin{theorem}
  $[[a = b]]$ iff $[[a ⇔ b]]$.
\end{theorem}

\subsubsection{Subject reduction}

\subsubsection{Progress}

\subsection{Consistency and canonicity}

\begin{figure}
\begin{mathpar}
  \inferrule[\ottdrulename{I-Univ}]
    {[[j < i]]}
    %---------------------------------------%
  {[[⟦ Type j ⟧ i ↘ {z | ∃ P. ⟦ z ⟧ j ↘ P}]]}
  \and
  \inferrule[\ottdrulename{I-Pi}]
    {[[⟦ A ⟧ i ↘ P1]] \and
     [[∀ y. y ∈ P1 → ∃ P2. R(y, P2)]] \and
     [[∀ y. ∀ P2. R(y, P2) → ⟦ B{x ↦ y} ⟧ i ↘ P2]]}
    %--------------------------------------------------------------------------------%
    {[[⟦ Πx : A. B ⟧ i ↘ {f | ∀ y. ∀ P2. R(y, P2) → y ∈ P1 → f y ∈ P2}]]}
  \and
  \inferrule[\ottdrulename{I-Pi'}]
    {[[⟦ A ⟧ i ↘ P1]] \and
     [[∀ y. y ∈ P1 → ∃ P2. ⟦ B{x ↦ y} ⟧ i ↘ P2]]}
    %--------------------------------------------------------------------------------%
    {[[⟦ Πx : A. B ⟧ i ↘ {f | ∀ y. ∀ P2. (⟦ B{x ↦ y} ⟧ i ↘ P2) → y ∈ P1 → f y ∈ P2}]]}
  \and
  \inferrule[\ottdrulename{I-Mty}]{~}
    {[[⟦ ⊥ ⟧ i ↘ ∅]]}
  \and
  \inferrule[\ottdrulename{I-Level<}]{~}
    {[[⟦ Level< j1 ⟧ i ↘ {z | ∃ j2. z ⇒* j2 ∧ j1 < j2}]]}
  \and
  \inferrule[\ottdrulename{I-Step}]
    {[[A ⇒ B]] \and
     [[⟦ B ⟧ i ↘ P]]}
     %--------------%
    {[[⟦ A ⟧ i ↘ P]]}
\end{mathpar}
\caption{Logical relation for closed types}
\label{fig:lr:closed}
\end{figure}

\subsection{Attempts at proving normalization}

\section{Conclusion and future work}

\subsection{Extensions}

\citet{gen-univ,univ-poly}

\bibliographystyle{plainurl}
\bibliography{main.bib}

\end{document}
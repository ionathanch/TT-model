\documentclass[a4paper,UKenglish,cleveref,autoref,thm-restate]{lipics-v2021}

% \pdfoutput=1
% \hideLIPIcs

\usepackage[supertabular]{ottalt}
\let\newlist\relax
\let\renewlist\relax
\usepackage{enumitem,xspace,doi}
\usepackage{mathpartir,mathtools,stmaryrd}
\usepackage[flushmargin,multiple,para]{footmisc} % para spacing is weird and ugly

\newcommand{\citep}[1]{\cite{#1}}
\newcommand{\citet}[1]{\cite{#1}}
\newcommand{\publicrepo}{\url{https://github.com/ionathanch/TT-model}}
\newcommand{\lang}{\textsf{TT}\@\xspace}
\newcommand{\titlebreak}{\texorpdfstring{\\}{}}
\newcommand{\ie}{\textit{i.e.}\@\xspace}
\newcommand{\eg}{\textit{e.g.}\@\xspace}
\newcommand{\etal}{\textit{et al.}\@\xspace}
\newcommand{\vs}{\textit{vs.}\@\xspace}
\newcommand{\apriori}{\textit{a priori}\@\xspace}
\newcommand{\welltyped}{well-\hspace{0pt}typed\@\xspace}
\newcommand{\wellfounded}{well-\hspace{0pt}founded\@\xspace}
\newcommand{\wellfoundedness}{well-\hspace{0pt}foundedness\@\xspace}
\newcommand{\wellformedness}{well-\hspace{0pt}formedness\@\xspace}
\newcommand{\welldefinedness}{well-\hspace{0pt}definedness\@\xspace}
\newcommand{\crude}{crude-\hspace{0pt}but-\hspace{0pt}effective\@\xspace}

\newcommand{\footfile}[1]{%
  \raggedright
  \href{\publicrepo{}/tree/main/TT-model/#1}{\texttt{#1}}
}
\newcommand{\footfilethm}[2]{%
  \raggedright
  \href{\publicrepo{}/tree/main/TT-model/#1}{\texttt{#1}}\texttt{:#2}
}

\setlength{\fboxsep}{1.5pt}

\newlength{\punctwidth}
% \nspace{<punct>} is a negative space the size of <punct>
\newcommand{\nspace}[1]{%
  \settowidth{\punctwidth}{#1}%
  \hspace*{-\the\punctwidth}%
}
% \npunct{<punct>} treats <punct> as having no width,
% so that footnotes after it can stack on top
\newcommand{\npunct}[1]{#1%
  \nspace{#1}%
}
% \nsup{<sup>}{<punct>} shifts <punct> left by
% the width of <sup> as a superscript
% so that footnotes *before* it will stack on top
\newcommand{\nsup}[2]{%
  \nspace{$^{#1}$}%
  #2%
}

\setlength{\fboxsep}{2pt}
\setlength{\abovecaptionskip}{0.5\baselineskip}

\hypersetup{
  colorlinks=true,
  urlcolor=blue,
  citecolor=magenta
}
\urlstyle{tt}

\title{Bounded First-Class Universe Levels \titlebreak in Type Theory}
\titlerunning{Bounded First-Class Universe Levels}
\authorrunning{J. Chan, S. Weirich}
\Copyright{Jonathan Chan, Stephanie Weirich}
\ccsdesc{Theory of computation~Type theory}
\keywords{type theory, universes, universe polymorphism}
\hideLIPIcs

\author{Jonathan Chan}
  {University of Pennsylvania, Philadelphia, USA}
  {jcxz@seas.upenn.edu}
  {0000-0003-0830-3180}
  {}

\author{Stephanie Weirich}
  {University of Pennsylvania, Philadelphia, USA}
  {sweirich@seas.upenn.edu}
  {0000-0002-6756-9168}
  {}

\supplementdetails[subcategory={source code},
  swhid={swh:1:dir:} % see https://www.softwareheritage.org/
]{Software}{https://github.com/ionathanch/TT-model}

\inputott{rules}

\acknowledgements{hi \href{https://types.pl}{\texttt{types.pl}}!}

\begin{document}

\maketitle

\begin{abstract}
  abstract
\end{abstract}

\section{Introduction}

\subsection{Comparison to other work}

\section{A basic type theory with bounded first-class universe levels}

We consider with a Curry-style type theory \`a la Russell,
where terms have no type annotations,
and there is no separate typing judgement for well-formedness of types.
To keep the type theory minimal, it contains only dependent functions,
an empty type, predicative universes, and bounded universe levels.
By convention, we use $[[a]], [[b]], [[c]]$ for terms,
$[[A]], [[B]], [[C]]$ for types,
and $[[k]], [[l]]$ for level terms.
The syntax is presented in nominally in \cref{fig:syntax},
although the mechanization uses de Bruijn indexing.
We write single substitution of a variable $[[x]]$ in a term $[[b]]$ by another term $[[a]]$
as $[[b{x ↦ a}]]$.
We also use $[[A → B]]$ as sugar for nondependent functions
$[[Πx : A. B]]$ where $[[x]]$ does not occur in $[[B]]$.

\begin{figure}
\begin{align*}
  i, j & \Coloneqq \texttt{<external universe levels>} \\
  x, y, z & \Coloneqq \texttt{<term variables>} \\
  a, b, c, A, B, C, k, \ell & \Coloneqq [[x]] \mid [[i]]
    \mid [[Πx : A. B]] \mid [[λx. b]] \mid [[b a]]
    \mid [[⊥]] \mid [[abs b]]
    \mid [[Type k]] \mid [[Level< l]] \\
  [[G]], [[D]] & \Coloneqq [[•]] \mid [[G, x : A]]
\end{align*}
\caption{Syntax}
\label{fig:syntax}
\end{figure}

The type theory is parametrized over a cofinal woset of levels,
\ie a set of levels that are well founded, totally ordered,
and each have some strictly larger level;
these properties are required when modelling the type theory.
Instances of such sets include the naturals $0, 1, 2, \dots$,
as well as the naturals extended by one limit ordinal $\omega$
and its successors $\omega + 1, \omega + 2, \dots$.
We continue to use these concrete levels for our examples.
These metalevel levels are internalized directly in system as terms $[[i]]$.

\begin{figure}
\begin{mathpar}
  \fbox{$[[⊢ G]]$} \qquad \fbox{$[[G ⊢ a : A]]$} \qquad \fbox{$[[a = b]]$} \hfill \\
  \inferrule[\ottdrulename{Nil}]{~}{[[⊢ •]]}
  \and
  \inferrule[\ottdrulename{Cons}]
    {[[⊢ G]] \and
     [[G ⊢ A : Type k]]}
    %------------------%
    {[[⊢ G, x : A]]}
  \and
  \inferrule[\ottdrulename{Var}]
    {[[⊢ G]] \and
     [[x : A ∈ G]]}
    %-------------%
    {[[G ⊢ x : A]]}
  \and
  \inferrule[\ottdrulename{Pi}]
    {[[G ⊢ A : Type k]] \and
     [[G, x : A ⊢ B : Type k]]}
    %--------------------------%
    {[[G ⊢ Πx : A. B : Type k]]}
  \and
  \inferrule[\ottdrulename{Lam}]
    {[[G ⊢ Πx : A. B : Type k]] \and
     [[G, x : A ⊢ b : B]]}
    %-------------------------%
    {[[G ⊢ λx. b : Πx : A. B]]}
  \and
  \inferrule[\ottdrulename{App}]
    {[[G ⊢ b : Πx : A. B]] \and
     [[G ⊢ a : A]]}
    %----------------------%
    {[[G ⊢ b a : B{x ↦ a}]]}
  \and
  \inferrule[\ottdrulename{Mty}]
    {[[G ⊢ Type k : Type l]]}
    %-----------------------%
    {[[G ⊢ ⊥ : Type k]]}
  \and
  \inferrule[\ottdrulename{Abs}]
    {[[G ⊢ A : Type k]] \and
     [[G ⊢ b : ⊥]]}
    %-----------------%
    {[[G ⊢ abs b : A]]}
  \and
  \inferrule[\ottdrulename{Conv}]
    {[[G ⊢ a : A]] \and
     [[G ⊢ B : Type k]] \and
     [[A = B]]}
    %------------------%
    {[[G ⊢ a : B]]}
\end{mathpar}
%
\begin{mathpar}
  \inferrule[\ottdrulename{E-Beta}]{~}{[[(λx. b) a = b{x ↦ a}]]} \and
  \inferrule[\ottdrulename{E-Refl}]{~}{[[a = a]]} \and
  \inferrule[\ottdrulename{E-Sym}]{[[a = b]]}{[[b = a]]} \and
  \inferrule[\ottdrulename{E-Trans}]{[[a = b]] \and [[b = c]]}{[[a = c]]} \and
  \cdots
\end{mathpar}

\caption{Typing and selected equality rules (no universes or levels)}
\label{fig:typing:basic}
\end{figure}

We begin first with the basic rules that don't concern universes or levels in \cref{fig:typing:basic},
consisting of a context well-formedness judgement $[[⊢ G]]$,
a typing judgement $[[G ⊢ a : A]]$, and an untyped definitional equality $[[a = b]]$.
\Rref{Lam} explicitly includes well-typedness of a function's type as a premise
rather than merely well-typedness of the domain type $[[A]]$
to guarantee that it lives at the same universe level as the codomain type $[[B]]$,
which we need to prove our fundamental theorem.
The remaining rules are otherwise as expected.
We use $\beta$-conversion as our definitional equality,
and omit the usual congruence rules.

\begin{figure}
\begin{mathpar}
  \inferrule[\ottdrulename{Univ}]
    {[[G ⊢ k : Level< l]]}
    %-----------------------%
    {[[G ⊢ Type k : Type l]]}
  \and
  \inferrule[\ottdrulename{Level<}]
    {[[G ⊢ Type k1 : Type l1]] \and
     [[G ⊢ k0 : Level< l0]]}
    %---------------------------%
    {[[G ⊢ Level< k0 : Type k1]]}
  \and
  \inferrule[\ottdrulename{Lvl}]
    {[[⊢ G]] \and
     [[i < j]]}
    %--------------------%
    {[[G ⊢ i : Level< j]]}
  \and
  \inferrule[\ottdrulename{Trans}]
    {[[G ⊢ k1 : Level< k2]] \and
     [[G ⊢ k2 : Level< k3]]}
    %----------------------%
    {[[G ⊢ k1 : Level< k3]]}
  \and
  \inferrule[\ottdrulename{Sub}]
    {[[G ⊢ A : Type k]] \and
     [[G ⊢ k : Level< l]]}
    %--------------------%
    {[[G ⊢ A : Type l]]}
\end{mathpar}
\caption{Typing rules (universes and levels)}
\label{fig:typing:univ}
\end{figure}

The rules relating to universes and levels are given in \cref{fig:typing:univ}.
By \rref{Lvl}, we can view the type constructor $[[Level< _]]$
as the internalization of the order on levels.
As the level type is combined with level bounding,
it is impossible to declare a level variable strictly less than itself.
The level type itself can be typed at any universe by \rref{Level<}
regardless of what the bounding level is.
For example, we can construct a derivation for $[[• ⊢ Level< 2 : Type 0]]$
solely knowing that $[[• ⊢ 2 : Level< 3]]$ and $[[• ⊢ Type 0 : Type 1]]$.

\Rref{Trans} internalizes transitivity of the order on levels,
which is now required since levels are terms in general and not only concrete levels.
For example, we can construct a derivation for $[[x : Level< o, y : Level< x ⊢ x : Level< o]]$,
where the levels $[[x]], [[y]]$ are variables.

\Rref{Sub} is a subsumption rule that permits lifting a type
from one universe to a higher universe.
This rule is weaker than a full cumulativity rule that accounts for
contravariance in the domain and covariance in the codomain of function types.
Therefore, for instance, $[[f : Type 2 → Type 0 ⊢ f : Type 1 → Type 1]]$ does \emph{not} hold.
Nonetheless, subsumption allows us to instead type the $\eta$-expansion
$[[f : Type 2 → Type 0 ⊢ λx. f x : Type 1 → Type 1]]$.

Finally, \rref{Univ} asserts that a universe at level $[[k]]$
lives in the universe at level $[[l]]$ when $[[k]]$ is strictly bounded by $[[l]]$.
Allowing universes with general level terms and not just concrete levels
to be well typed is what permits typing level-polymorphic types.
For example, we can derive a typing judgement for
the following level-polymorphic identity function type:
$$[[• ⊢ Πx : Level< o. Πy : Type x. y → y : Type o]]$$
$[[Level< o]]$ can be assigned an arbitrary type by \rref{Level},
$[[Type x]]$ has type $[[Type o]]$ by \rref{Univ} and \rref{Var},
and $[[y]]$ can be assigned type $[[Type o]]$ transitively
via \rref{Trans,Var}.
Then the entire term has type $[[Type o]]$ by repeated application of \rref{Pi}.

\section{Metatheory}

The key properties of the type theory that we prove are
type safety and logical consistency.
Type safety is proven using standard syntactic methods
to show progress and preservation (\ie subject reduction).
Consistency follows from the fundamental soundness theorem
for a logical relation on closed types
where the empty type is interpreted as the empty set of terms.
The fundamental theorem also gives canonicity results for other types:
closed terms of the universe reduce to types,
and closed terms of level types reduce to concrete levels.

All results are mechanized in Lean.
While the mechanization uses de Bruijn indexing and simultaneous substitutions,
we omit the details of manipulating these substitutions,
continuing to state theorems in nominal form
to focus on the ideas rather than the minutiae.

\subsection{Type safety}

Our type safety theorem is stated in terms of a call-by-name evaluation strategy,
which we define shortly.
In essence, closed, well-typed terms evaluate (if they terminate) to values,
which are type formers and constructors,
defined as follows.
$$[[v]] \Coloneqq [[i]] \mid [[Πx: A. B]] \mid [[λx. b]] \mid [[⊥]] \mid [[Type k]] \mid [[Level< l]]$$

\subsubsection{Reduction and conversion}

\begin{figure}
\begin{mathpar}
  \inferrule[\ottdrulename{P-Beta}]
    {[[b ⇒ b']] \and
     [[a ⇒ a']]}
    {[[(λx. b) a ⇒ b'{x ↦ a'}]]}
  \and
  \inferrule[\ottdrulename{P-Var}]{~}{[[x ⇒ x]]}
  \quad
  \inferrule[\ottdrulename{P-Mty}]{~}{[[⊥ ⇒ ⊥]]}
  \and
  \inferrule[\ottdrulename{P-Pi}]
    {[[A ⇒ A']] \and
     [[B ⇒ B']]}
    {[[Πx: A. B ⇒ Πx: A'. B']]}
  \and
  \inferrule[\ottdrulename{P-Lam}]
    {[[b ⇒ b']]}
    {[[λx. b ⇒ λx. b']]}
  \and
  \inferrule[\ottdrulename{P-App}]
    {[[b ⇒ b']] \and
     [[a ⇒ a']]}
    {[[b a ⇒ b' a']]}
  \and
  \inferrule[\ottdrulename{P-Abs}]
    {[[b ⇒ b']]}
    {[[abs b ⇒ abs b']]}
  \and
  \inferrule[\ottdrulename{P-Univ}]
    {[[k ⇒ k']]}
    {[[Type k ⇒ Type k']]}
  \and
  \inferrule[\ottdrulename{P-Level<}]
    {[[l ⇒ l']]}
    {[[Level< l ⇒ Level< l']]}
  \quad
  \inferrule[\ottdrulename{P-Lvl}]{~}{[[i ⇒ i]]}
\end{mathpar}
\caption{Parallel reduction rules}
\label{fig:par}
\end{figure}

Rather than working directly with $\beta$-reduction,
we use parallel reduction $[[a ⇒ b]]$,
defined in \cref{fig:par},
and its reflexive, transitive closure $[[a ⇒* b]]$,
into which call-by-name evaluation embeds.
We begin with simple lemmas about parallel reduction, stated without proof.

\begin{lemma}[Substitution (p.r.)] \label{lem:pars:subst}
  If $[[a ⇒* a']]$ and $[[b ⇒* b']]$,
  then $[[b{x ↦ a} ⇒* b'{x ↦ a'}]]$.
\end{lemma}

\begin{lemma}[Congruence (p.r.)] \label{lem:pars:cong}
  Parallel reduction is congruent,
  \eg if $[[A ⇒* A']]$ and $[[B ⇒* B']]$,
  then $[[Πx: A. B ⇒ Πx: A'. B']]$,
  and so on for all terms.
\end{lemma}

\begin{lemma}[Construction (p.r.)] \label{lem:pars:cons}
  Analogous constructors of parallel reduction hold
  for its reflexive, transitive closure,
  \eg if $[[b ⇒* b']]$ and $[[a ⇒* a']]$,
  then $[[(λx. b) a ⇒* b'{x ↦ a'}]]$.
\end{lemma}

\begin{lemma}[Inversion (p.r.)] \label{lem:pars:inv}
  If $[[v ⇒* c]]$, then $[[c]]$ is also a value of the same syntactic shape
  such that the reduction is congruent,
  \eg if $[[λx. b ⇒* c]]$, then $[[c]]$ is syntactically equal to $[[λx. b']]$
  for some $[[b']]$ such that $[[b ⇒* b']]$.
\end{lemma}

Similarly, rather than working directly with definitional equality,
we use conversion $[[a ⇔ b]]$,
which is defined in terms of parallel reduction.

\begin{definition}[Conversion]
  $[[a ⇔ b]]$ iff there exists a $[[c]]$ such that
  $[[a ⇒* c]]$ and $[[b ⇒* c]]$
\end{definition}

\begin{figure}
\begin{align*}
  \begin{aligned}
    [[(Πx: A. B) ^ T]] &\triangleq [[Πx: A ^ T. B ^ T]] \\
    [[(λx. b) ^ T]] &\triangleq [[λx. b ^ T]] \\
    [[(abs b) ^ T]] &\triangleq [[abs b ^ T]]
  \end{aligned}
  &
  \begin{aligned}
    [[(Type k) ^ T]] &\triangleq [[Type k ^ T]] \\
    [[(Level< l) ^ T]] &\triangleq [[Level< l ^ T]] \\
    [[a ^ T]] &\triangleq a ~ \textit{otherwise}
  \end{aligned}
  &
  \begin{aligned}
    [[(b a) ^ T]] &\triangleq
    \begin{cases}
      [[b' ^ T {x ↦ a ^ T}]] &\textit{if } [[b]] \textit{ is } [[λx. b']] \\
      [[b ^ T a ^ T]] &\textit{otherwise}
    \end{cases} \\
    &
  \end{aligned}
\end{align*}
\caption{Complete development}
\label{fig:taka}
\end{figure}

Proving that conversion is transitive requires proving confluence for parallel reduction,
which we prove using the notion of complete development by Takahashi~\citep{takahashi}.
Complete development $[[a ^ T]]$ is defined in \cref{fig:taka},
and is used to join parallel reductions and prove the diamond property.

\begin{lemma}[Completion (p.r.)] \label{lem:par:compl}
  If $[[a ⇒ b]]$, then $[[b ⇒ a ^ T]]$.
\end{lemma}

\begin{corollary}[Diamond (p.r.)] \label{lem:par:diamond}
  If $[[a ⇒ b]]$ and $[[a ⇒ c]]$,
  then there exists some $[[d]]$ such that $[[b ⇒ d]]$ and $[[c ⇒ d]]$.
  In particular, $[[d]]$ is $[[a ^ T]]$,
  with the reductions given by \nameref{lem:par:compl}.
\end{corollary}

\begin{theorem}[Confluence (p.r.)] \label{lem:par:confl}
  If $[[a ⇒* b]]$ and $[[a ⇒* c]]$,
  then there exists some $[[d]]$ such that $[[b ⇒* d]]$ and $[[c ⇒* d]]$.
\end{theorem}

\begin{corollary}[Properties of conversion] \label{lem:conv}
  Conversion is reflexive, symmetric, transitive, substitutive, and congruent.
  Transitivity requires \nameref{lem:par:confl};
  the remaining properties are straightforward
  from the corresponding properties of parallel reduction.
\end{corollary}

Inversion on parallel reduction gives syntactic consistency and injectivity of conversion.

\begin{lemma}[Syntactic consistency] \label{lem:par:consistency}
  If $[[v1]]$ and $[[v2]]$ have different syntactic shapes,
  then $[[v1 ⇔ v2]]$ is impossible.
\end{lemma}

\begin{lemma}[Injectivity (conv.)] ~
  \begin{enumerate}[topsep=0pt]
    \item If $[[Πx: A1. B1 ⇔ Πx: A2. B2]]$, then $[[A1 ⇔ A2]]$ and $[[B1 ⇔ B2]]$.
    \item If $[[Type k1 ⇔ Type k2]]$, then $[[k1 ⇔ k2]]$.
  \end{enumerate}
\end{lemma}

Finally, definitional equality is equivalent to conversion,
which allows us to use them interchangeably later on.
The right-to-left direction is proven using induction on parallel reduction,
while the left-to-right direction is proven by induction on definitional equality,
using the various properties of conversion.

\begin{theorem} \label{lem:eq-conv}
  $[[a = b]]$ iff $[[a ⇔ b]]$.
\end{theorem}

\subsubsection{Subject reduction}

To prove subject reduction,
we begin first with some simple inversion properties on typing derivations,
proven directly by induction.

\begin{lemma}[Context well-formedness] \label{lem:wt:wf}
  If $[[G ⊢ a : A]]$, then $[[⊢ G]]$.  
\end{lemma}

\begin{lemma}[Context well-typedness]
  If $[[⊢ G]]$ and $[[x : A ∈ G]]$,
  then there exists some $[[k]]$ such that $[[G ⊢ A : Type k]]$.
\end{lemma}

\begin{lemma}[Regularity] \label{lem:wt:reg}
  If $[[G ⊢ a : A]]$, then there exists some $[[k]]$ such that
  $[[G ⊢ A : Type k]]$.
\end{lemma}

Next, we require weakening, substitution, and replacement lemmas.
They follow from stronger forms of these lemmas involving simultaneous renaming and substitution,
whose details we omit.

\begin{lemma}[Weakening (w.t.)] \label{lem:wt:weak}
  If $[[⊢ G]]$, $[[G ⊢ B : Type k]]$, and $[[G ⊢ a : A]]$,
  then $[[G, x : B ⊢ a : A]]$, where $[[x]]$ is not in $[[a]]$ or $[[A]]$.
\end{lemma}

\begin{proof}
  A renaming lemma is proven by induction on the typing derivation of $[[a]]$,
  showing that applying well-scoped renamings preserves typing.
  Weakening is then the special case of a single renaming by $[[x]]$ to avoid capture.
\end{proof}

\begin{lemma}[Substitution (w.t.)] \label{lem:wt:subst}
  If $[[G ⊢ b : B]]$ and $[[G, x : B ⊢ a : A]]$,
  then $[[G ⊢ a{x ↦ b} : A{x ↦ b}]]$.
\end{lemma}

\begin{proof}
  A morphing lemma is proven by induction on the typing derivation of $[[a]]$,
  showing that applying well-typed substitutions preserves typing.
  Substitution is then the special case of a single substitution of $[[x]]$.
\end{proof}

\begin{lemma}[Replacement (w.t.)] \label{lem:wt:replace}
  If $[[A = B]]$, $[[G ⊢ B : Type k]]$, and $[[G, x : A ⊢ c : C]]$,
  then $[[G, x : B ⊢ c : C]]$.
\end{lemma}

\begin{proof}
  The morphing lemma allows us to change the context from one to the other
  as long as there is a well-typed substitution between them.
  We can show that the identity substitution is such a substitution
  by proving $[[G, x : B ⊢ x : A]]$.
  This follows from \rref{Conv},
  \nameref{lem:wt:wf} for well-typedness of $[[A]]$,
  and \nameref{lem:wt:weak} to weaken it.
\end{proof}

Finally, the proof of subject reduction requires many of the above lemmas.

\begin{theorem}[Subject reduction] \label{lem:preservation}
  If $[[a ⇒ b]]$ and $[[G ⊢ a : A]]$, then $[[G ⊢ b : A]]$.
\end{theorem}

\begin{proof}
  By induction on the typing derivation of $[[a]]$.
  The most complex case is when the reduction is \rref*{P-Beta},
  requiring \cref{lem:conv}, \nameref{lem:wt:subst},
  \nameref{lem:wt:replace}, and \nameref{lem:wt:reg}.
  Even so, the proof is standard,
  and the cases for the universe and level rules in \cref{fig:typing:univ}
  follow directly from the induction hypotheses.
\end{proof}

\subsubsection{Progress}

\begin{figure}
\begin{mathpar}
  \inferrule[\ottdrulename{N-Beta}]{~}
    {[[(λx. b) a ⇝ b{x ↦ a}]]}
  \and
  \inferrule[\ottdrulename{N-App}]
    {[[b ⇝ b']]}
    {[[b a ⇝ b' a]]}
  \and
  \inferrule[\ottdrulename{N-Abs}]
    {[[b ⇝ b']]}
    {[[abs b ⇝ abs b']]}
\end{mathpar}
\caption{Call by name reduction}
\label{fig:cbn}
\end{figure}

Our notion of evaluation in the progress and type safety theorems
is the reflexive, transitive closure  $[[a ⇝* b]]$
of call-by-name (cbn) reduction $[[a ⇝ b]]$,
defined in \cref{fig:cbn},
which reduces $\beta$-redexes and head positions.
A single step of cbn reduction embeds into
a single step of parallel reduction by induction.

\begin{lemma}
  If $[[a ⇝ b]]$ then $[[a ⇒ b]]$.
\end{lemma}

Because cbn reduces under eliminators for functions and proofs of falsehood,
we need to know what values of function and empty types are.
The following lemmas are proven by induction,
using inversion lemmas on typing derivations as needed.

\begin{lemma}[Canonical function values] \label{lem:canon:fun}
  If $[[G ⊢ v : Πx: A. B]]$,
  then $[[v]]$ has the syntactic shape $[[λx. b]]$ for some $[[b]]$.
\end{lemma}

\begin{lemma}[Canonical false values] \label{lem:canon:false}
  There is no $[[v]]$ such that $[[G ⊢ v : ⊥]]$.
\end{lemma}

Finally, we prove progress, which with subject reduction we show type safety:
closed, well-typed terms either reduce to a value, or must continue reducing.

\begin{theorem}[Progress] \label{lem:progress}
  If $[[• ⊢ a : A]]$, then either $[[a]]$ is a value
  or $[[a ⇝ b]]$ for some $[[b]]$.
\end{theorem}

\begin{proof}
  By induction on the typing derivation of $[[a]]$,
  using \cref{lem:canon:fun,lem:canon:false}
  in the cases for \rref{App,Abs}, respectively.
\end{proof}

\begin{theorem}[Type safety]
  If $[[• ⊢ a : A]]$ and $[[a ⇝* b]]$,
  then either $[[b]]$ is a value,
  or $[[b ⇝ c]]$ for some $[[c]]$.
\end{theorem}

\begin{proof}
  By induction on the reduction $[[a ⇝* c]]$.
  The reflexive case holds by \nameref{lem:progress}.
  In the transitive case where $[[a ⇝ b]]$ and $[[b ⇝* c]]$,
  the goal holds by the induction hypothesis on the latter reduction,
  using \nameref{lem:preservation} for well typedness of $[[b]]$
  from the former.
\end{proof}

\subsection{Consistency and canonicity}

To prove consistency and canonicity,
we use a logical relation to semantically interpret closed types as sets of closed terms;
these sets are backward closed under reduction,
so if a term reduces to something in the set, then it is also in the set.
The empty type is interpreted as the empty set,
universes as sets of terms that reduce to types,
and level types as sets of terms that reduce to concrete levels.
Consistency and canonicity then follow from the fundamental soundness theorem,
which states that if a term $[[a]]$ has type $[[A]]$,
then $[[a]]$ is in the interpretation of $[[A]]$.
The structure of the logical relation and the soundness proof
is adapted from the mechanization by Liu~\citep{lr-pearl},
and we cover important details here,
especially as they pertain to universes and levels.

\subsubsection{Logical relation for closed types}

The logical relation is written as $[[⟦ A ⟧ i ↘ P]]$,
where $[[A]]$ is the type, $[[P]]$ is the set of terms,
and $[[i]]$ is the universe level of the type.
A set of terms $[[P]]$ is mechanized as a predicate on terms,
though we to write $[[a ∈ P]]$ in lieu of $[[P]]([[a]])$
to say that $[[a]]$ is in the set,
and we use set-builder notation in lieu of explicit abstractions.
When proving properties of the logical relation,
we require no other axioms than function extensionality and propositional extensionality;
for transparency, we mark the lemmas in which they are used with $\dagger$.

Because universes are interpreted as sets of types
which themselves have interpretations at a lower universe level,
to ensure that the interpretation is well defined,
the mechanization implements it as an inductive definition
parametrized by interpretations at lower levels,
then ties the knot by well-founded induction on levels.
For clarity and concision, we ignore these mechanization details
and present the logical relation in \cref{fig:lr:closed}
without worrying about well-foundedness.

\begin{figure}
\begin{mathpar}
  \inferrule[\ottdrulename{I-Mty}]{~}
    {[[⟦ ⊥ ⟧ i ↘ ∅]]}
  \and
  \inferrule[\ottdrulename{I-Univ}]
    {[[j < i]]}
    %---------------------------------------%
  {[[⟦ Type j ⟧ i ↘ {z | ∃ P. ⟦ z ⟧ j ↘ P}]]}
  \and
  \inferrule[\ottdrulename{I-Level<}]{~}
    {[[⟦ Level< j1 ⟧ i ↘ {z | ∃ j2. z ⇒* j2 ∧ j1 < j2}]]}
  \and
  \inferrule[\ottdrulename{I-Step}]
    {[[A ⇒ B]] \and
     [[⟦ B ⟧ i ↘ P]]}
     %--------------%
    {[[⟦ A ⟧ i ↘ P]]}
  \and
  \inferrule[\ottdrulename{I-Pi}]
    {[[⟦ A ⟧ i ↘ P1]] \and
     [[∀ y. y ∈ P1 → ∃ P2. R(y, P2)]] \\\\
     [[∀ y. ∀ P2. R(y, P2) → ⟦ B{x ↦ y} ⟧ i ↘ P2]]}
    %--------------------------------------------------------------------------------%
    {[[⟦ Πx : A. B ⟧ i ↘ {f | ∀ y. ∀ P2. R(y, P2) → y ∈ P1 → f y ∈ P2}]]}
\end{mathpar}
\caption{Logical relation for closed types}
\label{fig:lr:closed}
\end{figure}

Let us get the easier cases out of the way.
\Rref{I-Step} backward closes the interpretation under reduction of the type,
so a type has an interpretation if it reduces to a type with an interpretation.
We show shortly that forward closure under reduction of the type also holds,
as well as backward closure under reduction of the \emph{terms} in the interpretations.%
\footnote{We will not require forward closure.}
The interpretation of the empty type as the empty set is given by \rref{I-Mty}.

Because we consider the interpretation of closed types only,
and we explicitly have a constructor for backward closure,
the only other constructors we need are those for normal, closed types.
In particular, we need only consider $[[Type j]]$ and $[[Level< j1]]$
with concrete levels rather than arbitrary level terms.
The interpretation of $[[Level< j1]]$ given by \rref{I-Level<}
is the set of level terms strictly less than $[[j1]]$;
more precisely, it is the set of terms that reduce to such concrete levels.
The interpretation of $[[Type j]]$ given by \rref{I-Univ}
is the set of types that have an interpretation.

The intuition behind \rref{I-Pi} for function types is that a function $[[f]]$
is in its interpretation if for every argument $[[y]]$ in the interpretation of the domain,
the application $[[f y]]$ is in the interpretation of the codomain.
Because we are dealing with dependent types,
the interpretation of the codomain varies with the argument,
so we need to ensure first that the interpretation exists
for \emph{every} argument in the interpretation of the domain,
and that $[[f y]]$ is in the \emph{particular} interpretation of the codomain.
It then sounds like we would want \rref{I-Pi'} below.
%
\begin{mathpar}
  \inferrule[\ottdrulename{I-Pi'}]
    {[[⟦ A ⟧ i ↘ P1]] \and
     [[∀ y. y ∈ P1 → ∃ P2. ⟦ B{x ↦ y} ⟧ i ↘ P2]]}
    %--------------------------------------------------------------------------------%
    {[[⟦ Πx : A. B ⟧ i ↘ {f | ∀ y. ∀ P2. (⟦ B{x ↦ y} ⟧ i ↘ P2) → y ∈ P1 → f y ∈ P2}]]}
\end{mathpar}

The problem is that the interpretation is not strictly positive in the conclusion,
so \rref*{I-Pi'} as a constructor is not well defined.
\Rref{I-Pi} therefore uses an auxiliary relation $[[R]]$
that relates the argument $[[y]]$ to the interpretation of the codomain $[[B{x ↦ y}]]$.
\Rref{I-Pi'} then holds by instantiating $[[R(y, P2)]]$ with $[[⟦B{x ↦ y}⟧ i ↘ P2]]$ in \rref{I-Pi}.
This is the same trick used by Liu~\citep{lr-pearl},
whose origins are documented by Anand and Rahli~\citep{mech-nuprl}.

We require of the logical relation inversion properties for each constructor,
along with properties that hold \apriori for syntactic typing:
conversion and cumulativity.
A key intermediate lemma is functionality,
\ie that the interpretation of a type is deterministic.
We begin with closures over reductions to prove conversion.

\begin{lemma}[Forward and backward closure (l.r.)] \label{lem:lr:pars} ~
  \begin{enumerate}
    \item If $[[⟦A⟧ i ↘ P]]$ and either $[[A ⇒ B]]$ or $[[A ⇒* B]]$,
      then $[[⟦B⟧ i ↘ P]]$.
    \item If $[[⟦B⟧ i ↘ P]]$ and either $[[A ⇒ B]]$ or $[[A ⇒* B]]$,
      then $[[⟦A⟧ i ↘ P]]$.
  \end{enumerate}
\end{lemma}

\begin{proof} ~
  \begin{enumerate}
    \item For $[[A ⇒ B]]$, by induction on the logical relation,
      using \nameref{lem:par:diamond} in the \rref*{I-Step} case.
      \nameref{lem:pars:subst} is needed in the \rref*{I-Pi} case
      to manipulate the substitution in the function codomain.
      For $[[A ⇒* B]]$, by induction on this reduction.
    \item For $[[A ⇒* B]]$, by induction on this reduction,
      using \rref{I-Step}. \qedhere
  \end{enumerate}
\end{proof}

\begin{corollary}[Conversion (l.r.)]
  If $[[⟦A⟧ i ↘ P]]$ and $[[A ⇔ B]]$,
  then $[[⟦B⟧ i ↘ P]]$,
  using forward and backward closure.
\end{corollary}

The final closure lemma we need is backward closure of the terms in the interpretations.
When proving the fundamental theorem,
we encounter situations where our goal requires inclusion of a reduced term in an interpretation,
while induction hypotheses only piece together inclusion of the term before reduction.

\begin{lemma}[Backward closure] \label{lem:lr:back}
  If $[[⟦A⟧ i ↘ P]]$ and $[[a ⇒* b]]$,
  then $[[b ∈ P]]$ implies $[[a ∈ P]]$.
\end{lemma}

\begin{proof}
  By induction on the logical relation.
  In the \rref*{I-Univ} case, where $[[a]]$ and $[[b]]$ are types,
  we use backward closure from \cref{lem:lr:pars}.
\end{proof}

Cumulativity holds directly by induction on the logical relation.

\begin{lemma}[Cumulativity (l.r.)] \label{lem:lr:cumul}
  Suppose $[[i < j]]$. If $[[⟦A⟧ i ↘ P]]$, then $[[⟦A⟧ j ↘ P]]$.
\end{lemma}

The inversion principles for each constructor of the logical relation
hold by induction, using properties of parallel reduction as needed.
However, it is the inversion principle for \rref{I-Pi'} that we want.
The issue lies in the set of terms of the interpretation:
if we do not yet know that the sets are unique,
then inversion on \rref{I-PI} gives \emph{some} interpretation $[[P1]]$ of the codomain,
but we do not know whether it is \emph{the} interpretation that is required.
We solve this by proving functionality.

\begin{lemma}[Fixed-level functionality (l.r.)]$\!\!{\dagger}$ \label{lem:lr:fixed-func}
  If $[[⟦A⟧ i ↘ P]]$ and $[[⟦A⟧ i ↘ Q]]$, then $[[P]] = [[Q]]$.
\end{lemma}

\begin{proof}
  By induction on the first logical relation,
  then generally inversion on the second,
  except for the \rref*{I-Step} case,
  which holds directly by the induction hypothesis
  and forward closure on the second logical relation.
  The complex case is \rref*{I-Pi},
  where we must prove the two sets of terms equal,
  knowing by the induction hypotheses
  that the interpretations of the domain and codomain yield equal sets.
  Because sets are encoded as predicates,
  we need to use predicate extensionality,
  \ie function extensionality followed by propositional extensionality.
  It then suffices to show that membership in one set implies membership in the other,
  which holds using the induction hypotheses.
\end{proof}

Functionality holds even with different universe levels,
the idea being that the interpretation of a type is independent
of the level at which it lives.

\begin{lemma}[Functionality (l.r.)] \label{lem:lr:func}
  If $[[⟦A⟧ i ↘ P]]$ and $[[⟦A⟧ j ↘ Q]]$, then $[[P]] = [[Q]]$.
\end{lemma}

\begin{proof}
  By totality of the order on levels,
  either $[[i]]$ and $[[j]]$ are equal,
  or one is strictly larger than the other.
  In the latter case,
  we use \nameref{lem:lr:cumul} to lift the logical relation at the lower level to the higher level.
  Then the sets are equal by \nameref{lem:lr:fixed-func}.
\end{proof}

Finally, we are able to prove the inversion property for \rref{I-Pi'},
which we explicitly state below.

\begin{lemma}[Inversion on function types (l.r.)]$\!\!{\dagger}$ \label{lem:lr:inv-pi}
  If $[[⟦Πx: A. B⟧ i ↘ P]]$,
  then there exists a $[[P1]]$ such that:
  \begin{enumerate}
    \item \label{lem:inv-pi:goal:A} $[[⟦ A ⟧ i ↘ P1]]$;
    \item \label{lem:inv-pi:goal:B} $[[∀ y. y ∈ P1 → ∃ P2. ⟦ B{x ↦ y} ⟧ i ↘ P2]]$; and
    \item \label{lem:inv-pi:goal:P} $[[P]] = [[{f | ∀ y. ∀ P2. (⟦ B{x ↦ y} ⟧ i ↘ P2) → y ∈ P1 → f y ∈ P2}]]$.
  \end{enumerate}
\end{lemma}

\begin{proof}
  By inversion on the logical relation,
  which gives $[[P1]]$ and $[[R]]$ such that the following hold:
  \begin{enumerate}[start=4]
    \item \label{lem:inv-pi:hyp:A} $[[⟦ A ⟧ i ↘ P1]]$;
    \item \label{lem:inv-pi:hyp:R} $[[∀ y. y ∈ P1 → ∃ P2. R(y, P2)]]$;
    \item \label{lem:inv-pi:hyp:B} $[[∀ y. ∀ P2. R(y, P2) → ⟦ B{x ↦ y} ⟧ i ↘ P2]]$; and
    \item \label{lem:inv-pi:hyp:P} $[[P]] = [[{f | ∀ y. ∀ P2. R(y, P2) → y ∈ P1 → f y ∈ P2}]]$.
  \end{enumerate}
  \ref{lem:inv-pi:goal:A} holds directly by \ref{lem:inv-pi:hyp:A},
  and \ref{lem:inv-pi:goal:B} holds by combining \ref{lem:inv-pi:hyp:R} and \ref{lem:inv-pi:hyp:B}.
  To show that the sets in \ref{lem:inv-pi:goal:P} and \ref{lem:inv-pi:hyp:P} are equal,
  we again use predicate extensionality.
  \begin{itemize}
    \item \textit{\ref{lem:inv-pi:goal:P} implies \ref{lem:inv-pi:hyp:P}.}
      Supposing $[[y]]$ and $[[P2]]$,
      we have three hypotheses $[[(⟦ B{x ↦ y} ⟧ i ↘ P2) → y ∈ P1 → f y ∈ P2]]$,
      $[[R(y, P2)]]$, and $[[y ∈ P1]]$.
      From \ref{lem:inv-pi:hyp:B} on the second hypothesis,
      we have $[[⟦ B{x ↦ y} ⟧ i ↘ P2]]$,
      so we can apply the first hypothesis to get $[[f y ∈ P2]]$.
    \item \textit{\ref{lem:inv-pi:hyp:P} implies \ref{lem:inv-pi:goal:P}.}
      Supposing $[[y]]$ and $[[P2]]$,
      we have three hypotheses $[[R(y, P2) → y ∈ P1 → f y ∈ P2]]$,
      $[[⟦ B{x ↦ y} ⟧ i ↘ P2]]$, and $[[y ∈ P1]]$.
      Instantiating the first hypothesis using \ref{lem:inv-pi:hyp:R},
      we know there exists a $[[P2']]$ such that $[[f y ∈ P2']]$.
      From \ref{lem:inv-pi:hyp:B}, we also know that $[[⟦ B{x ↦ y} ⟧ i ↘ P2']]$.
      Then by \nameref{lem:lr:func}, we have $[[P2]] = [[P2']]$, so $[[f y ∈ P2]]$.
      \qedhere
  \end{itemize}
\end{proof}

It is worthwhile to also explicitly state the inversion principle
asserting that types that have interpretations are indeed one of the four types,
proven by induction on the logical relation.

\begin{lemma}[Inversion (l.r.)] \label{lem:lr:inv}
  If $[[⟦C⟧ i ↘ P]]$, then one of the following holds:
  \begin{itemize}
    \item There exist $[[A]]$ and $[[B]]$ such that $[[C ⇒* Πx: A. B]]$;
    \item There exists $[[i]]$ such that $[[C ⇒* Type i]]$;
    \item There exists $[[i]]$ such that $[[C ⇒* Level< i]]$; or
    \item $[[C ⇒* ⊥]]$.
  \end{itemize}
\end{lemma}

\subsubsection{Fundamental soundness theorem}

Although the logical relation relates closed types to sets of closed terms,
the fundamental theorem is proven over syntactic typing of open terms,
so we need a notion of semantic typing that handles closing over the terms
in a given typing context with a simultaneous substitution.
Semantic typing is then elementhood of a term in the interpretation of its type
for any substitution that closes them both.

At this point, referring to simultaneous substitutions is inevitable.
We denote them as $[[s]]$, and write $[[s, x ↦ a]]$
for its extension by a single substitution of $[[x]]$ by $[[a]]$.
In the mechanization, semantic well-typedness of a substitution $[[s ⊧ G]]$
is defined similarly to semantic typing,
but the admissible rules defined in \cref{fig:sem:subst} are more convenient.

\begin{definition}
  A substitution $[[s]]$ is semantically well typed
  with respect to a context $[[G]]$ iff for every $[[x : A ∈ G]]$,
  there exist $[[i]], [[P]]$ such that
  $[[⟦A{s}⟧ i ↘ P]]$ and $[[x{s} ∈ P]]$.
\end{definition}

\begin{figure}
\begin{mathpar}
  \mprset{fraction={\cdot\cdots\cdot}}
  \inferrule[\ottdrulename{S-Nil}]{~}{[[s ⊧ •]]}
  \and
  \inferrule[\ottdrulename{S-Cons}]
    {[[s ⊧ G]] \and
     [[⟦A{s}⟧ i ↘ P]] \and
     [[a ∈ P]]}
    % --------------------- %
    {[[s, x ↦ a ⊧ G, x : A]]}
\end{mathpar}
\caption{Semantically well-typed substitutions}
\label{fig:sem:subst}
\end{figure}

\begin{definition}[Semantic typing]
  A term $[[a]]$ is semantically well typed with type $[[A]]$ under context $[[G]]$,
  written $[[G ⊧ a : A]]$, iff for every $[[s]]$ such that $[[s ⊧ G]]$,
  there exist $[[i]], [[P]]$ such that
  $[[⟦A{s}⟧ i ↘ P]]$ and $[[a{s} ∈ P]]$.
\end{definition}

The fundamental soundness theorem of syntactic typing with respect to semantic typing
states that syntactic typing implies semantic typing.
The cases corresponding to the rules in \cref{fig:typing:basic} are routine
by construction and inversion of \rref{I-Pi,I-Mty}~\citep{lr-pearl},
so we do not cover them all here.
Instead, we detail only the \rref*{I-Lam} case to highlight
where some of the above lemmas are used,
followed by the cases for the rules in \cref{fig:typing:univ}
that are unique to our system.
For concision, we skip steps involving massaging substitutions into the right shape.

\begin{theorem}[Soundness] \label{thm:soundness}
  If $[[G ⊢ a : A]]$, then $[[G ⊧ a : A]]$.
\end{theorem}

\begin{proof}
  By induction on the typing derivation.
  In each case, we suppose that $[[s ⊧ G]]$.
  \begin{itemize}
    \item \textit{\Rref{Lam}.}
      The premises are $[[G ⊢ Πx: A. B : Type k]]$ and $[[G, x : A ⊢ b : B]]$,
      concluding with $[[G ⊢ λx. b : Πx: A. B]]$.
      By the induction hypothesis on the first premise,
      the function type is in the interpretation of a universe,
      so it also has an interpretation by inversion,
      allowing us to apply \nameref{lem:lr:inv-pi}.
      This gives $[[⟦A{s}⟧ i ↘ P1]]$, $[[⟦ B{s, x ↦ a} ⟧ i ↘ P2]]$, and $[[a ∈ P1]]$,
      where the goal is now to show that $[[(λx. b) a ∈ P2]]$.
      By \rref{S-Cons} and the induction hypothesis on the second premise,
      we have $[[⟦B{s, x ↦ a}⟧ i' ↘ P2']]$ and $[[b{x ↦ a} ∈ P2']]$ for some $[[i']], [[P2']]$.
      By \nameref{lem:lr:func}, we have that $[[P2]] = [[P2']]$.
      Finally, by \nameref{lem:lr:back} on \rref{P-Beta} and $[[b{x ↦ a} ∈ P2]]$,
      we obtain $[[(λx. b) a ∈ P2]]$.
    \item \textit{\Rref{Univ}.}
      The premise is $[[G ⊢ k : Level< l]]$,
      concluding with $[[G ⊢ Type k : Type l]]$.
      By the induction hypothesis on the premise,
      followed by inversion on the interpretation of level types,
      we know that $[[k{s} ⇒* i1]]$ and $[[l{s} ⇒* i2]]$ such that $[[i1 < i2]]$.
      By cofinality, we also know that there must exist a $[[j]]$ such that $[[i2 < j]]$.
      The goal is now to show that $[[⟦Type (l{s})⟧ j ↘ {z | ∃ P. ⟦ z ⟧ i2 ↘ P}]]$
      and $[[⟦Type (k{s})⟧ i2 ↘ {z | ∃ P. ⟦ z ⟧ i1 ↘ P}]]$.
      These are both constructed using \rref{I-Univ} and \cref{lem:lr:pars}.
    \item \textit{\Rref{Level<}.}
      The premises are $[[G ⊢ Type k1 : Type l1]]$ and $[[G ⊢ k0 : Level< l0]]$,
      concluding with $[[G ⊢ Level< k0 : Type k1]]$.
      By the induction hypothesis on the first premises,
      $[[Type (k1{s})]]$ is in the interpretation of a universe.
      By inversion, we know that it too has an interpretation as a universe,
      so it remains to show that $[[⟦Level< (k0{s})⟧ j ↘ P]]$ for some $[[P]]$,
      where $[[k1{s} ⇒* j]]$.
      By the induction on the second premise,
      followed by inversion on the interpretation of level types,
      we know that $[[k0{s} ⇒* i]]$ for some $[[i]]$.
      Then the goal is constructed using \rref{I-Level<} and \cref{lem:lr:pars}.
    \item \textit{\Rref{Lvl}.} Straightforward by construction using \rref{I-Level<}.
    \item \textit{\Rref{Trans}.}
      The premises are $[[G ⊢ k1 : Level< k2]]$ and $[[G ⊢ k2 : Level< k3]]$,
      concluding with $[[G ⊢ k1 : Level< k3]]$.
      By the induction hypotheses on the two premises,
      followed by inversion on the interpretation of level types,
      we know that $[[k1{s} ⇒* i1]]$, $[[k2{s} ⇒* i2]]$, $[[k2{s} ⇒* i2']]$, and $[[k3{s} ⇒* i3]]$
      such that $[[i1 < i2]]$ and $[[i2' < i3]]$.
      By \nameref{lem:par:confl} and \nameref{lem:par:consistency},
      it must be that $[[i2]] = [[i2']]$.
      From the second inversion, we already know that $[[Level< (k3{s})]]$ has an interpretation,
      so it remains to show that $[[k1{s} ⇒* i1]]$ and $[[k3{s} ⇒* i3]]$ such that $[[i1 < i3]]$,
      which holds by transitivity.
    \item \textit{\Rref{Sub}.}
      The premises are $[[G ⊢ A : Type k]]$ and $[[G ⊢ k : Level< l]]$,
      concluding with $[[G ⊢ A : Type l]]$.
      By induction on the first premise,
      followed by inversion on the interpretation of universes,
      we know that $[[k{s} ⇒* i]]$ and $[[⟦A{s}⟧ i ↘ P]]$ for some $[[P]]$.
      By induction on the second premise,
      followed by inversion on the interpretation of levels,
      we know that $[[k{s} ⇒* i']]$ and $[[l{s} ⇒* j]]$ such that $[[i' < j]]$.
      By \nameref{lem:par:confl} and \nameref{lem:par:consistency},
      it must be that $[[i]] = [[i']]$.
      Similar to the \rref{Univ} case,
      we can show that $[[Type (l{s})]]$ has an interpretation as a universe.
      The final goal is then to show that $[[⟦A{s}⟧ j ↘ P]]$,
      which holds by \nameref{lem:lr:cumul} on $[[i < j]]$.
      \qedhere
  \end{itemize}
\end{proof}

Consistency and various canonicity results then follow from the fundamental theorem as corollaries.

\begin{corollary}[Consistency]
  There is no $[[b]]$ such that $[[• ⊢ b : ⊥]]$ holds.
  If there were, by \nameref{thm:soundness},
  we would have $[[• ⊧ b : ⊥]]$.
  Instantiating with the identity substitution,
  then inverting on the interpretation of $[[⊥]]$,
  we would have that $[[b ∈ ∅]]$, which is a contradiction.
\end{corollary}

\begin{corollary}[Canonicity of types]
  If $[[• ⊢ C : Type k]]$,
  then either $[[C ⇒* Πx: A. B]]$, $[[C ⇒* Type i]]$, $[[C ⇒* Level< i]]$, or $[[C ⇒* ⊥]]$.
  By \nameref{thm:soundness},
  instantiating with the identity substitution,
  we have some $[[j]], [[Q]]$ such that $[[⟦Type k⟧ j ↘ Q]]$ and $[[C ∈ Q]]$.
  By inversion on the former,
  we then have some $[[i]], [[P]]$ such that $[[k ⇒* i]]$ and $[[⟦C⟧ i ↘ P]]$.
  Then the goal holds by \nameref{lem:lr:inv}.
\end{corollary}

\begin{corollary}[Canonicity of levels]
  If $[[• ⊢ k : Level< l]]$,
  then $[[k ⇒* i]]$ for some concrete level $[[i]]$.
  By \nameref{thm:soundness},
  instantiating with the identity substitution,
  we have some $[[j]], [[P]]$ such that $[[⟦Level< l⟧ j ↘ P]]$ and $[[k ∈ P]]$.
  By inversion on the former,
  we then have that $[[l ⇒* i2]]$ and $[[k ⇒* i1]]$ such that $[[i1 < i2]]$.
\end{corollary}

\subsection{Counterexample to normalization}

Our type theory is not normalizing.
While directly declaring an ill-founded level $[[x : Level< x]]$ is impossible,
we can construct such a level in an inconsistent context.
Then it becomes possible to type the universe at this level as its own type.
\Cref{fig:type-in-type} explicitly constructs the key part of the typing derivation
for $[[Type (abs x)]] : [[Type (abs x)]]$ where $[[x]] : [[⊥]]$.
With an instance of type-in-type,
it is possible to construct a nonnormalizing lambda term,
for instance via Hurkens' paradox~\citep{hurkens}.

\begin{figure}
\begin{mathpar}
  \inferrule*[Left=\rref*{Univ}]{
  \inferrule*[Left=\rref*{Abs}]{
    \inferrule*[Left=\rref*{Level<}]{
      \inferrule*[Left=\rref*{Univ}]{
      \inferrule*[Left=\rref*{Lvl}]{0 < 1}{[[x : ⊥ ⊢ 0 : Level< 1]]}}
      {[[x : ⊥ ⊢ Type 0 : Type 1]]}
      \and
      \inferrule*[Right=\rref*{Abs}]{
      \inferrule*[]{\dots}{[[x : ⊥ ⊢ Level< 0 : Type 0]]}
      \and
      \inferrule*[Right=\rref*{Var}]{[[x : ⊥ ∈ x : ⊥]]}{[[x : ⊥ ⊢ x : ⊥]]}}
      {[[x : ⊥ ⊢ abs x : Level< 0]]}}
      {[[x : ⊥ ⊢ Level< (abs x) : Type 0]]}
    \and
    \inferrule*[Right=\rref*{Var}]{[[x : ⊥ ∈ x : ⊥]]}{[[x : ⊥ ⊢ x : ⊥]]}}
    {[[x : ⊥ ⊢ abs x : Level< (abs x)]]}}
  {[[x : ⊥ ⊢ Type (abs x) : Type (abs x)]]}
\end{mathpar}
\caption{Type-in-type in an inconsistent context}
\label{fig:type-in-type}
\end{figure}

The ability to assign different types to the term $[[abs x]]$ is key to constructing this derivation.
If the eliminator for falsehood required a type annotation,
and more importantly if type annotations required comparison in definitional equality,
we could only construct a derivation for
$[[Type (abs' (Level< (abs' (Level< 0) x)) x)]] : [[Type (abs' (Level< 0) x)]]$,
which can no longer be used as type-in-type.
For similar reasons, we cannot use $[[x]] : [[:concrete: ΠA: Type i. A]]$
to construct the ill-founded level, as the type arguments will be incomparable.

It is unclear whether adding a type annotation to $[[abs _]]$
(or removing the empty type entirely) would resolve the issue of nonnormalization,
as we have not found a counterexample without eliminating falsehoods.
Conversely, it is also unclear how to define extend the logical relation to prove normalization
by generalizing it to open types and terms.
The issue lies in the interpretation of a universe at a level that is a neutral term.

Consider for example $[[x : Level< o, y : Level< x ⊢ Type y : Type x]]$.
What types live in $[[Type y]]$?
If $[[x]]$ is $[[0]]$, then there is no possible $[[y]]$,
and $[[Type y]]$ has no interpretation as a universe;
otherwise, it \emph{could} have an interpretation.
Without assuming that $[[x]]$ reduces to a canonical, concrete level,
we have no way of interpreting $[[Type y]]$.
We cannot simply say that universes with neutral levels only contain neutral terms, either,
as $[[Type x]]$ is such a universe that clearly contains the normal term $[[Type y]]$.

\section{Conclusion and future work}

\subsection{Extensions}

\citet{gen-univ,univ-poly}

\bibliographystyle{plainurl}
\bibliography{main.bib}

\end{document}